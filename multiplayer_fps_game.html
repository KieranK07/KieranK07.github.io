<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Multiplayer FPS (Firestore demo)</title>
    <style>
        html,body{height:100%;margin:0;background:#0b0b12;color:#fff;font-family:Inter,system-ui,Segoe UI,Arial}
        canvas{display:block}
        #blocker{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.7);z-index:20}
        #instructions{width:420px;background:rgba(18,18,20,0.9);padding:20px;border-radius:12px;border:1px solid #263238;text-align:center}
        #instructions input{width:70%;padding:8px;border-radius:6px;border:1px solid #333;background:#07070a;color:#fff}
        #instructions button{margin-left:8px;padding:9px 12px;border-radius:8px;border:none;background:#00e5ff;color:#002}
        #hud{position:fixed;left:18px;bottom:18px;background:rgba(0,0,0,0.5);padding:8px 12px;border-radius:8px}
        #players-panel{position:fixed;top:12px;right:12px;background:rgba(0,0,0,0.45);padding:8px;border-radius:8px;min-width:180px;max-height:60vh;overflow:auto}
        #crosshair{position:fixed;left:50%;top:50%;width:8px;height:8px;margin-left:-4px;margin-top:-4px;border-radius:50%;background:rgba(255,255,255,0.8);pointer-events:none}
    </style>
    <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js",
        "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/"
      }
    }
    </script>
</head>
<body>
    <div id="blocker">
        <div id="instructions">
            <h2 style="margin:0 0 10px">Multiplayer FPS — Enter name</h2>
            <div>
                <input id="player-name" placeholder="Your name" maxlength="24" />
                <button id="play-btn">Play</button>
            </div>
            <p style="margin-top:12px;font-size:0.9em;color:#bfc">WASD to move · SPACE to jump · MOUSE to look · CLICK to shoot · ESC to leave</p>
        </div>
    </div>

    <div id="crosshair"></div>
    <div id="hud">Health: <span id="health-val">100</span></div>
    <div id="players-panel">Players<ul id="players-list" style="margin:6px 0 0 14px;padding:0;list-style:disc"></ul></div>

    <script type="module">
    import * as THREE from 'three';
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js';
    import { getAuth, signInAnonymously, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js';
    import { getFirestore, collection, doc, setDoc, onSnapshot, updateDoc, deleteDoc, serverTimestamp } from 'https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js';

    // Minimal, rebuilt single-file version implementing the requested realtime presence

    // Use fallback config (from your earlier message)
    const firebaseConfig = {
        apiKey: "AIzaSyAZ5Xc4Hl1_bN9KLf8S32OxSH_P6JOZwx0",
        authDomain: "fpsmult-5f414.firebaseapp.com",
        projectId: "fpsmult-5f414",
        storageBucket: "fpsmult-5f414.firebasestorage.app",
        messagingSenderId: "353781130843",
        appId: "1:353781130843:web:3a04c9d1f49b52f153417e"
    };

    // DOM
    const blocker = document.getElementById('blocker');
    const playBtn = document.getElementById('play-btn');
    const playerNameInput = document.getElementById('player-name');
    const playersListEl = document.getElementById('players-list');
    const healthValEl = document.getElementById('health-val');

    // Three.js basic scene
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000011);
    const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
    camera.position.y = 1.7;
    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(innerWidth, innerHeight);
    document.body.appendChild(renderer.domElement);

    // Simple player body
    const playerBody = new THREE.Object3D();
    playerBody.add(camera);
    scene.add(playerBody);

    // Simple floor
    const grid = new THREE.GridHelper(100, 100, 0x00ffff, 0x004444);
    grid.position.y = 0.01;
    scene.add(grid);

    // Movement
    const move = {f:0,b:0,l:0,r:0};
    const velocity = new THREE.Vector3();
    let canJump = false;
    const clock = new THREE.Clock();

    // Game/player state
    let app, auth, db;
    let userId = null;
    let playerDocRef = null;
    let playersCollectionRef = null;
    let localPlayer = null;
    const otherPlayers = {}; // id -> {data,mesh}

    // Heartbeat interval (ms)
    const HEARTBEAT_MS = 5000;
    let heartbeatTimer = null;

    // Helper: create simple mesh for remote players
    function makePlayerMesh(color){
        const g = new THREE.CapsuleGeometry(0.4, 0.8, 4, 12);
        const m = new THREE.MeshBasicMaterial({color,wireframe:true});
        const mesh = new THREE.Mesh(g,m);
        return mesh;
    }

    // Pointer lock wiring
    document.addEventListener('pointerlockchange', ()=>{
        const locked = document.pointerLockElement === document.body;
        blocker.style.display = locked ? 'none' : 'flex';
        // If pointerlock lost and we have a player, remove them
        if(!locked && playerDocRef){
            // remove player doc
            deletePlayerDoc().catch(()=>{});
        }
    });

    // Basic controls
    document.addEventListener('mousemove', (e)=>{
        if(document.pointerLockElement !== document.body) return;
        const movementX = e.movementX || 0;
        const movementY = e.movementY || 0;
        const euler = new THREE.Euler().setFromQuaternion(camera.quaternion, 'YXZ');
        euler.y -= movementX * 0.002;
        euler.x -= movementY * 0.002;
        euler.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, euler.x));
        camera.quaternion.setFromEuler(euler);
    });

    document.addEventListener('keydown', (e)=>{
        if(e.code === 'KeyW') move.f = 1;
        if(e.code === 'KeyS') move.b = 1;
        if(e.code === 'KeyA') move.l = 1;
        if(e.code === 'KeyD') move.r = 1;
        if(e.code === 'Space' && canJump) { velocity.y = 8; canJump = false; }
        if(e.code === 'Escape') {
            // user wants to leave: delete player doc and show blocker
            deletePlayerDoc().catch(()=>{});
            document.exitPointerLock && document.exitPointerLock();
            blocker.style.display = 'flex';
        }
    });
    document.addEventListener('keyup', (e)=>{
        if(e.code === 'KeyW') move.f = 0;
        if(e.code === 'KeyS') move.b = 0;
        if(e.code === 'KeyA') move.l = 0;
        if(e.code === 'KeyD') move.r = 0;
    });

    // Resize
    addEventListener('resize', ()=>{
        camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight);
    });

    // Render loop
    function animate(){
        requestAnimationFrame(animate);
        const dt = clock.getDelta();
        // movement
        const speed = 6;
        const dir = new THREE.Vector3(move.r-move.l, 0, move.b-move.f).normalize();
        if(dir.length()>0){
            const rot = new THREE.Euler().setFromQuaternion(camera.quaternion, 'YXZ');
            dir.applyAxisAngle(new THREE.Vector3(0,1,0), rot.y);
            playerBody.position.x += dir.x * speed * dt;
            playerBody.position.z += dir.z * speed * dt;
        }
        velocity.y += -25 * dt;
        playerBody.position.y += velocity.y * dt;
        if(playerBody.position.y < 0.9){ velocity.y = 0; playerBody.position.y = 0.9; canJump = true; }

        // Update local player doc periodically done elsewhere
        // Render others
        renderer.render(scene, camera);
    }
    animate();

    // Firestore helpers
    async function initFirebaseAndAuth(){
        app = initializeApp(firebaseConfig);
        auth = getAuth(app);
        db = getFirestore(app);
        // players collection path (same structure as your earlier file)
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-fps-app';
        playersCollectionRef = collection(db, 'artifacts', appId, 'public', 'data', 'players');

        return new Promise((resolve,reject)=>{
            onAuthStateChanged(auth, async (user)=>{
                if(user){
                    userId = user.uid;
                    resolve(user);
                }
            });
            // trigger anonymous sign-in
            signInAnonymously(auth).catch(reject);
        });
    }

    async function joinGameWithName(displayName){
        if(!db || !userId) throw new Error('not-initialized');
        playerDocRef = doc(db, playersCollectionRef.path, userId);
        const spawn = new THREE.Vector3((Math.random()-0.5)*30, 1, (Math.random()-0.5)*30);
        localPlayer = {
            id: userId,
            name: displayName,
            position: {x: spawn.x, y: spawn.y, z: spawn.z},
            rotation: {x:0,y:0,z:0},
            health: 100,
            color: '#' + new THREE.Color(Math.random()*0xffffff).getHexString(),
            lastSeen: serverTimestamp()
        };
        // set initial doc
        await setDoc(playerDocRef, localPlayer);

        // heartbeat every HEARTBEAT_MS
        heartbeatTimer = setInterval(()=>{
            if(playerDocRef) updateDoc(playerDocRef, { lastSeen: serverTimestamp(),
                'position.x': playerBody.position.x, 'position.y': playerBody.position.y, 'position.z': playerBody.position.z
            }).catch(()=>{});
        }, HEARTBEAT_MS);

        // Listen for health changes on our doc
        onSnapshot(playerDocRef, (snap)=>{
            if(!snap.exists()) return;
            const data = snap.data();
            if(data.health !== undefined){ healthValEl.textContent = data.health; }
        });

        // Listen for collection changes
        onSnapshot(collection(db, playersCollectionRef.path), (snapshot)=>{
            // Rebuild or patch players
            snapshot.docChanges().forEach(change=>{
                const d = change.doc.data();
                const id = d.id;
                if(id === userId) return; // skip ourselves
                if(change.type === 'added' || change.type === 'modified'){
                    if(!otherPlayers[id]){
                        const mesh = makePlayerMesh(d.color || '#00ffff');
                        scene.add(mesh);
                        otherPlayers[id] = {data:d, mesh};
                    }
                    const entry = otherPlayers[id];
                    entry.data = d;
                    entry.mesh.position.set(d.position.x, d.position.y, d.position.z);
                    if(d.color) entry.mesh.material.color.set(d.color);
                } else if(change.type === 'removed'){
                    if(otherPlayers[id]){ scene.remove(otherPlayers[id].mesh); delete otherPlayers[id]; }
                }
            });
            rebuildPlayersListUI();
        });
    }

    function rebuildPlayersListUI(){
        playersListEl.innerHTML = '';
        if(localPlayer){
            const li = document.createElement('li'); li.textContent = `${localPlayer.name} (you)`; playersListEl.appendChild(li);
        }
        Object.values(otherPlayers).forEach(p=>{
            const li = document.createElement('li'); li.textContent = p.data.name || p.data.id.substring(0,6); playersListEl.appendChild(li);
        });
    }

    async function deletePlayerDoc(){
        try{
            if(heartbeatTimer) { clearInterval(heartbeatTimer); heartbeatTimer = null; }
            if(playerDocRef) await deleteDoc(playerDocRef);
            playerDocRef = null; localPlayer = null;
        }catch(e){ console.warn('could not delete player doc', e); }
    }

    // Play button handler
    playBtn.addEventListener('click', async ()=>{
        const name = (playerNameInput.value || '').trim() || `Player-${Math.floor(Math.random()*9000)+1000}`;
        try{
            blocker.querySelector('h2').textContent = 'Connecting...';
            await initFirebaseAndAuth();
            await joinGameWithName(name);
            // sync initial position
            playerBody.position.set(localPlayer.position.x, localPlayer.position.y, localPlayer.position.z);
            // request pointer lock
            document.body.requestPointerLock && document.body.requestPointerLock();
        }catch(e){
            console.error(e);
            blocker.querySelector('h2').textContent = 'Connection failed';
        }
    });

    // Remove player on page unload
    window.addEventListener('beforeunload', ()=>{
        // best-effort synchronous delete is not possible; but we try to fire the async delete
        if(playerDocRef){ deletePlayerDoc().catch(()=>{}); }
    });

    // Optional: tidy up stale players on load (client-side); we can't delete other docs without permission
    // Recommend adding a server-side cleanup to remove docs where lastSeen is older than X.

    </script>
</body>
</html>
             onSnapshot(playerDocRef, (doc) => {
                if(doc.exists()){
                    const data = doc.data();
                    player.health = data.health;
                    hud.textContent = `Health: ${player.health}`;
                    if(player.health <= 0) {
                        respawn();
                    }
                }
            });
        }
        
        let lastUpdateTime = 0;
        const updateInterval = 100; // ms

        function updatePlayerOnFirebase() {
            if (Date.now() - lastUpdateTime > updateInterval) {
                 if (playerDocRef) {
                    const currentRotation = new THREE.Euler().setFromQuaternion(camera.quaternion, 'YXZ');
                    updateDoc(playerDocRef, {
                        "position.x": playerBody.position.x,
                        "position.y": playerBody.position.y,
                        "position.z": playerBody.position.z,
                        "rotation.x": 0, // We only care about Y-axis rotation for the body
                        "rotation.y": currentRotation.y,
                        "rotation.z": 0,
                        "lastUpdate": serverTimestamp()
                    }).catch(err => console.error("Error updating player:", err));
                }
                lastUpdateTime = Date.now();
            }
        }
        
        // --- CONTROLS & MOVEMENT ---
        function setupPointerLock() {
            instructions.addEventListener('click', () => {
                document.body.requestPointerLock();
            });
            document.addEventListener('pointerlockchange', () => {
                blocker.style.display = document.pointerLockElement ? 'none' : 'flex';
            });
        }

        function setupEventListeners() {
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousedown', onMouseDown);
            window.addEventListener('resize', onWindowResize);
        }

        // Wire up Play button and name input
        const playBtn = document.getElementById('play-btn');
        const playerNameInput = document.getElementById('player-name');
        playBtn.addEventListener('click', async () => {
            const name = (playerNameInput.value || '').trim() || `Player-${Math.floor(Math.random()*9000)+1000}`;
            // Store on global so joinGame can access it before auth user displayName exists
            window.__display_name = name;

            // Start Firebase auth and join process
            await firebaseSetup();

            // After firebase auth completes, hide the blocker and request pointer lock
            if (document.body.requestPointerLock) {
                document.body.requestPointerLock();
            }
        });

        // If user presses Escape we should remove them and show the blocker UI again
        document.addEventListener('keydown', async (ev) => {
            if (ev.code === 'Escape') {
                // If we have a player doc, delete it and reset UI
                try { if (playerDocRef) await deleteDoc(playerDocRef); } catch (e) { }
                blocker.style.display = 'flex';
            }
        });

        function onMouseMove(event) {
            if (document.pointerLockElement) {
                const movementX = event.movementX || 0;
                const movementY = event.movementY || 0;

                const euler = new THREE.Euler(0, 0, 0, 'YXZ');
                euler.setFromQuaternion(camera.quaternion);

                euler.y -= movementX * 0.002;
                euler.x -= movementY * 0.002;
                euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, euler.x));
                
                camera.quaternion.setFromEuler(euler);
            }
        }

        function onKeyDown(event) {
            switch(event.code) {
                case 'KeyW': moveDirection.forward = 1; break;
                case 'KeyS': moveDirection.backward = 1; break;
                case 'KeyA': moveDirection.left = 1; break;
                case 'KeyD': moveDirection.right = 1; break;
                case 'Space': if (canJump) playerVelocity.y = jumpHeight; break;
            }
        }

        function onKeyUp(event) {
            switch(event.code) {
                case 'KeyW': moveDirection.forward = 0; break;
                case 'KeyS': moveDirection.backward = 0; break;
                case 'KeyA': moveDirection.left = 0; break;
                case 'KeyD': moveDirection.right = 0; break;
            }
        }

        function updateMovement(delta) {
             const moveSpeed = playerSpeed * delta;
            
            const moveVector = new THREE.Vector3(
                moveDirection.right - moveDirection.left,
                0,
                moveDirection.backward - moveDirection.forward
            ).normalize();

            if (moveVector.length() > 0) {
                 // Use the camera's Y-axis rotation to make movement relative to view
                 const euler = new THREE.Euler(0, 0, 0, 'YXZ');
                 euler.setFromQuaternion(camera.quaternion);
                 moveVector.applyAxisAngle(new THREE.Vector3(0, 1, 0), euler.y);

                 playerBody.position.x += moveVector.x * moveSpeed;
                 playerBody.position.z += moveVector.z * moveSpeed;
            }

            // Gravity
            playerVelocity.y += gravity * delta;
            playerBody.position.y += playerVelocity.y * delta;
            
            handleCollisions();
        }

        function handleCollisions() {
            const playerBox = new THREE.Box3().setFromObject(playerBody);
            let onGround = false;

            world.children.forEach(child => {
                if (child === floor || child === playerBody) return;
                const worldBox = new THREE.Box3().setFromObject(child);
                
                if (playerBox.intersectsBox(worldBox)) {
                    const intersection = playerBox.clone().intersect(worldBox);
                    const size = intersection.getSize(new THREE.Vector3());
                    const center = intersection.getCenter(new THREE.Vector3());

                    const playerCenter = playerBox.getCenter(new THREE.Vector3());

                    // Determine overlap direction and correct position by finding the minimum penetration axis
                    if (size.y < size.x && size.y < size.z) { // Vertical collision is the shallowest
                        if (playerCenter.y > center.y) { // Hitting from above (landing)
                           playerBody.position.y += size.y;
                           playerVelocity.y = 0;
                           onGround = true;
                        } else { // Hitting from below (bumping head)
                            playerBody.position.y -= size.y;
                            playerVelocity.y *= -0.5;
                        }
                    } else if (size.x < size.z) { // Horizontal X collision is shallower
                        if (playerCenter.x > center.x) {
                            playerBody.position.x += size.x;
                        } else {
                            playerBody.position.x -= size.x;
                        }
                    } else { // Horizontal Z collision is shallower
                         if (playerCenter.z > center.z) {
                            playerBody.position.z += size.z;
                        } else {
                            playerBody.position.z -= size.z;
                        }
                    }
                }
            });

            // Floor collision
            if (playerBody.position.y < 0.9) {
                playerVelocity.y = 0;
                playerBody.position.y = 0.9;
                onGround = true;
            }
            canJump = onGround;
        }

        // --- GAME LOGIC ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2(0, 0); // Center of the screen

        function onMouseDown(event) {
            if (document.pointerLockElement) {
                shoot();
            }
        }

        function shoot() {
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(scene.children, true);
            
            for (let i = 0; i < intersects.length; i++) {
                let obj = intersects[i].object;
                 // Traverse up to find the parent player mesh if we hit a child
                while(obj.parent && !obj.name) {
                    obj = obj.parent;
                }
                
                if (obj.name && players[obj.name]) {
                    const targetId = obj.name;
                    handleHit(targetId);
                    break;
                }
            }
        }
        
        async function handleHit(targetId) {
            console.log(`Hit player ${targetId}`);
            const targetRef = doc(db, playersCollectionRef.path, targetId);
            const targetPlayer = players[targetId].data;
            const newHealth = Math.max(0, targetPlayer.health - 20);
            
            await updateDoc(targetRef, { health: newHealth });
            
            // Visual feedback for hitting an enemy
            hitMarker.style.backgroundColor = 'rgba(255, 255, 255, 0.8)';
            setTimeout(() => {
                hitMarker.style.backgroundColor = 'rgba(255, 255, 255, 0)';
            }, 100);
        }

        async function respawn() {
            const spawnPoint = spawnPoints[Math.floor(Math.random() * spawnPoints.length)];
            playerBody.position.copy(spawnPoint);
            playerVelocity.set(0,0,0);
            
            if (playerDocRef) {
                await updateDoc(playerDocRef, {
                    health: 100,
                    "position.x": spawnPoint.x,
                    "position.y": spawnPoint.y,
                    "position.z": spawnPoint.z
                });
            }
        }

        // --- WINDOW & RENDER LOOP ---
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();

            if (document.pointerLockElement) {
                updateMovement(delta);
                updatePlayerOnFirebase();
            }

            composer.render();
        }
    </script>
</body>
</html>


