<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multiplayer FPS Game</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            background-color: #111;
            color: white;
        }
        canvas {
            display: block;
        }
        #blocker {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #instructions {
            width: 50%;
            text-align: center;
            cursor: pointer;
            padding: 20px;
            background: rgba(20,20,20,0.8);
            border-radius: 12px;
            border: 1px solid #444;
        }
        #instructions h1 {
            font-size: 2.5em;
            margin-bottom: 0.5em;
        }
        #instructions p {
            font-size: 1.2em;
            line-height: 1.5;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.7);
            transform: translate(-50%, -50%);
            pointer-events: none;
        }
        #hud {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background-color: rgba(0,0,0,0.5);
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 1.2em;
        }
        #hit-marker {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 0, 0, 0);
            pointer-events: none;
            transition: background-color 0.1s ease-out;
        }
        #player-info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.5);
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 0.9em;
        }
    </style>
    <!-- Import Map to resolve module specifiers -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js",
            "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/"
        }
    }
    </script>
</head>
<body>
    <div id="blocker">
        <div id="instructions">
            <h1>Simple FPS</h1>
            <p>Click to Play</p>
            <p><strong>Controls:</strong></p>
            <p>WASD to move | SPACE to jump | MOUSE to look | CLICK to shoot</p>
        </div>
    </div>
    <div id="crosshair"></div>
    <div id="hud">Health: 100</div>
    <div id="hit-marker"></div>
    <div id="player-info">Connecting...</div>
    
    <!-- Firebase Libraries -->
    <script type="module">
        // Three.js Imports
        import * as THREE from 'three';
        import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass.js';
        
                // Firebase Imports (modular SDK v10)
                import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
                import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
                import { getFirestore, doc, setDoc, onSnapshot, collection, deleteDoc, updateDoc, serverTimestamp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

                // Firebase configuration (user-provided)
                // If you want to override this at runtime (e.g. for testing), set window.__firebase_config
                const FIREBASE_CONFIG = window.__firebase_config ?? {
                    apiKey: "AIzaSyAZ5Xc4Hl1_bN9KLf8S32OxSH_P6JOZwx0",
                    authDomain: "fpsmult-5f414.firebaseapp.com",
                    projectId: "fpsmult-5f414",
                    storageBucket: "fpsmult-5f414.firebasestorage.app",
                    messagingSenderId: "353781130843",
                    appId: "1:353781130843:web:3a04c9d1f49b52f153417e"
                };

        // --- GAME SETUP ---
        let camera, scene, renderer, composer;
        let world, floor;
        let player, playerBody;
        let controls;
        const players = {}; // To store other players' data and meshes
        
    let db, auth, userId;
    let playerDocRef;
    let playersCollectionRef; // Firestore CollectionReference

        const clock = new THREE.Clock();
        const moveDirection = { forward: 0, backward: 0, left: 0, right: 0 };
        const playerVelocity = new THREE.Vector3();
        let canJump = false;
        const playerSpeed = 10;
        const jumpHeight = 8;
        const gravity = -25;
        
        const spawnPoints = [
            new THREE.Vector3(-15, 2, -15),
            new THREE.Vector3(15, 2, 15),
            new THREE.Vector3(15, 2, -15),
            new THREE.Vector3(-15, 2, 15),
        ];

        // --- DOM ELEMENTS ---
        const blocker = document.getElementById('blocker');
        const instructions = document.getElementById('instructions');
        const hud = document.getElementById('hud');
        const hitMarker = document.getElementById('hit-marker');
        const playerInfoEl = document.getElementById('player-info');

        // --- INITIALIZE ---
        init();

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000011); // Deep dark blue background
            scene.fog = new THREE.Fog(0x000011, 40, 100); // Fog to match

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.y = 1.7;

            // Player Body (for collision)
            const playerGeometry = new THREE.BoxBufferGeometry(0.8, 1.8, 0.8);
            const playerMaterial = new THREE.MeshBasicMaterial({ visible: false });
            playerBody = new THREE.Mesh(playerGeometry, playerMaterial);
            playerBody.add(camera); // Attach camera to the player body
            scene.add(playerBody);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.toneMapping = THREE.ReinhardToneMapping; // Necessary for bloom
            document.body.appendChild(renderer.domElement);

            setupPostProcessing();
            createWorld();
            setupLights();
            setupPointerLock();
            setupEventListeners();
            
            // Start Firebase after basic scene is ready
            firebaseSetup();
            
            animate();
        }

        function createWorld() {
            world = new THREE.Group();
            scene.add(world);

            // Tron Grid Floor
            const gridHelper = new THREE.GridHelper(100, 100, 0x00ffff, 0x004444);
            gridHelper.position.y = 0.01; // Slightly above the physics plane
            scene.add(gridHelper);

            // Invisible physical floor plane
            const floorGeometry = new THREE.PlaneGeometry(100, 100);
            const floorMaterial = new THREE.MeshBasicMaterial({ visible: false });
            floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            world.add(floor); // Add to world for ground detection
            
            // Walls and Obstacles - now glowing outlines
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0x00ffff, linewidth: 2 });

            const boxes = [
                // Outer walls
                { s: [100, 4, 2], p: [0, 2, 50] }, { s: [100, 4, 2], p: [0, 2, -50] },
                { s: [2, 4, 100], p: [50, 2, 0] }, { s: [2, 4, 100], p: [-50, 2, 0] },
                // Inner obstacles
                { s: [10, 3, 2], p: [0, 1.5, -10] }, { s: [10, 3, 2], p: [0, 1.5, 10] },
                { s: [2, 3, 10], p: [-10, 1.5, 0] }, { s: [2, 3, 10], p: [10, 1.5, 0] },
                { s: [8, 3, 8], p: [20, 1.5, 20] }, { s: [8, 3, 8], p: [-20, 1.5, -20] }
            ];

            boxes.forEach(b => {
                const wallGeometry = new THREE.BoxGeometry(b.s[0], b.s[1], b.s[2]);
                
                // Invisible collision mesh
                const wallCollision = new THREE.Mesh(wallGeometry, new THREE.MeshBasicMaterial({ visible: false }));
                wallCollision.position.set(b.p[0], b.p[1], b.p[2]);
                world.add(wallCollision);

                // Visible glowing edges
                const edges = new THREE.EdgesGeometry(wallGeometry);
                const line = new THREE.LineSegments(edges, lineMaterial);
                line.position.copy(wallCollision.position);
                scene.add(line);
            });
        }
        
        function setupLights() {
            // Minimal lighting for a TRON theme, relying on emissive materials
            const ambientLight = new THREE.AmbientLight(0x4040ff, 0.5); // A faint blue ambient light
            scene.add(ambientLight);
        }

        function setupPostProcessing() {
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.2;
            bloomPass.strength = 1.2;
            bloomPass.radius = 0.5;

            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);
        }

        // --- FIREBASE LOGIC ---
        async function firebaseSetup() {
            // Application/namespace id used for multi-tenant storage within the project
            const appId = window.__app_id ?? 'default-fps-app';

            const app = initializeApp(FIREBASE_CONFIG);
            db = getFirestore(app);
            auth = getAuth(app);

            // Players collection path: /artifacts/{appId}/public/data/players
            playersCollectionRef = collection(db, 'artifacts', appId, 'public', 'data', 'players');

            // Make debug handles accessible from console
            window._firebase = { app, db, auth };

            onAuthStateChanged(auth, async (user) => {
                if (user) {
                    userId = user.uid;
                    playerInfoEl.textContent = `Player ID: ${userId.substring(0,6)}`;
                    await joinGame();
                    listenForPlayers();
                    listenForPlayerHealth();
                }
            });

            try {
                // If a custom token was provided at runtime, use it; otherwise sign in anonymously
                if (window.__initial_auth_token) {
                    await signInWithCustomToken(auth, window.__initial_auth_token);
                } else {
                    await signInAnonymously(auth);
                }
            } catch (error) {
                console.error("Authentication failed: ", error);
                playerInfoEl.textContent = "Authentication Failed";
            }
        }
        
        async function joinGame() {
            // Create a DocumentReference under the players collection with the user's uid
            playerDocRef = doc(playersCollectionRef, userId);
            const startPos = spawnPoints[Math.floor(Math.random() * spawnPoints.length)];
            
            player = {
                id: userId,
                position: { x: startPos.x, y: startPos.y, z: startPos.z },
                rotation: { x: 0, y: 0, z: 0 },
                health: 100,
                color: `#${new THREE.Color(Math.random() * 0xffffff).getHexString()}`,
                lastUpdate: serverTimestamp()
            };

            playerBody.position.copy(startPos);
            
            await setDoc(playerDocRef, player);

            // Clean up on unload
            window.addEventListener('beforeunload', () => {
                try { deleteDoc(playerDocRef); } catch (e) { /* best-effort */ }
            });
        }
        
        function listenForPlayers() {
            // Listen to the players collection for added/modified/removed players
            onSnapshot(playersCollectionRef, (snapshot) => {
                snapshot.docChanges().forEach((change) => {
                    const playerData = change.doc.data();
                    if (playerData.id === userId) return;

                    if (change.type === "added" || change.type === "modified") {
                        if (!players[playerData.id]) {
                            // Create new player mesh - TRON style
                            const geometry = new THREE.CapsuleGeometry(0.5, 1, 4, 16);
                            const material = new THREE.MeshBasicMaterial({ color: playerData.color, wireframe: true });
                            const mesh = new THREE.Mesh(geometry, material);
                            mesh.name = playerData.id; // For raycasting
                            players[playerData.id] = { data: playerData, mesh: mesh };
                            scene.add(mesh);
                        }
                        
                        // Update position and rotation
                        const p = players[playerData.id];
                        p.data = playerData;
                        p.mesh.position.set(playerData.position.x, playerData.position.y, playerData.position.z);
                        p.mesh.rotation.set(playerData.rotation.x, playerData.rotation.y, playerData.rotation.z);
                        p.mesh.material.color.set(playerData.color);

                    } else if (change.type === "removed") {
                        if (players[playerData.id]) {
                            scene.remove(players[playerData.id].mesh);
                            delete players[playerData.id];
                        }
                    }
                });
            });
        }

        function listenForPlayerHealth() {
             onSnapshot(playerDocRef, (doc) => {
                if(doc.exists()){
                    const data = doc.data();
                    player.health = data.health;
                    hud.textContent = `Health: ${player.health}`;
                    if(player.health <= 0) {
                        respawn();
                    }
                }
            });
        }
        
        let lastUpdateTime = 0;
        const updateInterval = 100; // ms

        function updatePlayerOnFirebase() {
            if (Date.now() - lastUpdateTime > updateInterval) {
                 if (playerDocRef) {
                    const currentRotation = new THREE.Euler().setFromQuaternion(camera.quaternion, 'YXZ');
                    updateDoc(playerDocRef, {
                        "position.x": playerBody.position.x,
                        "position.y": playerBody.position.y,
                        "position.z": playerBody.position.z,
                        "rotation.x": 0, // We only care about Y-axis rotation for the body
                        "rotation.y": currentRotation.y,
                        "rotation.z": 0,
                        "lastUpdate": serverTimestamp()
                    }).catch(err => console.error("Error updating player:", err));
                }
                lastUpdateTime = Date.now();
            }
        }
        
        // --- CONTROLS & MOVEMENT ---
        function setupPointerLock() {
            instructions.addEventListener('click', () => {
                document.body.requestPointerLock();
            });
            document.addEventListener('pointerlockchange', () => {
                blocker.style.display = document.pointerLockElement ? 'none' : 'flex';
            });
        }

        function setupEventListeners() {
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousedown', onMouseDown);
            window.addEventListener('resize', onWindowResize);
        }

        function onMouseMove(event) {
            if (document.pointerLockElement) {
                const movementX = event.movementX || 0;
                const movementY = event.movementY || 0;

                const euler = new THREE.Euler(0, 0, 0, 'YXZ');
                euler.setFromQuaternion(camera.quaternion);

                euler.y -= movementX * 0.002;
                euler.x -= movementY * 0.002;
                euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, euler.x));
                
                camera.quaternion.setFromEuler(euler);
            }
        }

        function onKeyDown(event) {
            switch(event.code) {
                case 'KeyW': moveDirection.forward = 1; break;
                case 'KeyS': moveDirection.backward = 1; break;
                case 'KeyA': moveDirection.left = 1; break;
                case 'KeyD': moveDirection.right = 1; break;
                case 'Space': if (canJump) playerVelocity.y = jumpHeight; break;
            }
        }

        function onKeyUp(event) {
            switch(event.code) {
                case 'KeyW': moveDirection.forward = 0; break;
                case 'KeyS': moveDirection.backward = 0; break;
                case 'KeyA': moveDirection.left = 0; break;
                case 'KeyD': moveDirection.right = 0; break;
            }
        }

        function updateMovement(delta) {
             const moveSpeed = playerSpeed * delta;
            
            const moveVector = new THREE.Vector3(
                moveDirection.right - moveDirection.left,
                0,
                moveDirection.backward - moveDirection.forward
            ).normalize();

            if (moveVector.length() > 0) {
                 // Use the camera's Y-axis rotation to make movement relative to view
                 const euler = new THREE.Euler(0, 0, 0, 'YXZ');
                 euler.setFromQuaternion(camera.quaternion);
                 moveVector.applyAxisAngle(new THREE.Vector3(0, 1, 0), euler.y);

                 playerBody.position.x += moveVector.x * moveSpeed;
                 playerBody.position.z += moveVector.z * moveSpeed;
            }

            // Gravity
            playerVelocity.y += gravity * delta;
            playerBody.position.y += playerVelocity.y * delta;
            
            handleCollisions();
        }

        function handleCollisions() {
            const playerBox = new THREE.Box3().setFromObject(playerBody);
            let onGround = false;

            world.children.forEach(child => {
                if (child === floor || child === playerBody) return;
                const worldBox = new THREE.Box3().setFromObject(child);
                
                if (playerBox.intersectsBox(worldBox)) {
                    const intersection = playerBox.clone().intersect(worldBox);
                    const size = intersection.getSize(new THREE.Vector3());
                    const center = intersection.getCenter(new THREE.Vector3());

                    const playerCenter = playerBox.getCenter(new THREE.Vector3());

                    // Determine overlap direction and correct position by finding the minimum penetration axis
                    if (size.y < size.x && size.y < size.z) { // Vertical collision is the shallowest
                        if (playerCenter.y > center.y) { // Hitting from above (landing)
                           playerBody.position.y += size.y;
                           playerVelocity.y = 0;
                           onGround = true;
                        } else { // Hitting from below (bumping head)
                            playerBody.position.y -= size.y;
                            playerVelocity.y *= -0.5;
                        }
                    } else if (size.x < size.z) { // Horizontal X collision is shallower
                        if (playerCenter.x > center.x) {
                            playerBody.position.x += size.x;
                        } else {
                            playerBody.position.x -= size.x;
                        }
                    } else { // Horizontal Z collision is shallower
                         if (playerCenter.z > center.z) {
                            playerBody.position.z += size.z;
                        } else {
                            playerBody.position.z -= size.z;
                        }
                    }
                }
            });

            // Floor collision
            if (playerBody.position.y < 0.9) {
                playerVelocity.y = 0;
                playerBody.position.y = 0.9;
                onGround = true;
            }
            canJump = onGround;
        }

        // --- GAME LOGIC ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2(0, 0); // Center of the screen

        function onMouseDown(event) {
            if (document.pointerLockElement) {
                shoot();
            }
        }

        function shoot() {
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(scene.children, true);
            
            for (let i = 0; i < intersects.length; i++) {
                let obj = intersects[i].object;
                 // Traverse up to find the parent player mesh if we hit a child
                while(obj.parent && !obj.name) {
                    obj = obj.parent;
                }
                
                if (obj.name && players[obj.name]) {
                    const targetId = obj.name;
                    handleHit(targetId);
                    break;
                }
            }
        }
        
        async function handleHit(targetId) {
            console.log(`Hit player ${targetId}`);
            const targetRef = doc(playersCollectionRef, targetId);
            const targetPlayer = players[targetId].data;
            const newHealth = Math.max(0, targetPlayer.health - 20);
            
            await updateDoc(targetRef, { health: newHealth });
            
            // Visual feedback for hitting an enemy
            hitMarker.style.backgroundColor = 'rgba(255, 255, 255, 0.8)';
            setTimeout(() => {
                hitMarker.style.backgroundColor = 'rgba(255, 255, 255, 0)';
            }, 100);
        }

        async function respawn() {
            const spawnPoint = spawnPoints[Math.floor(Math.random() * spawnPoints.length)];
            playerBody.position.copy(spawnPoint);
            playerVelocity.set(0,0,0);
            
            if (playerDocRef) {
                await updateDoc(playerDocRef, {
                    health: 100,
                    "position.x": spawnPoint.x,
                    "position.y": spawnPoint.y,
                    "position.z": spawnPoint.z
                });
            }
        }

        // --- WINDOW & RENDER LOOP ---
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();

            if (document.pointerLockElement) {
                updateMovement(delta);
                updatePlayerOnFirebase();
            }

            composer.render();
        }
    </script>
</body>
</html>


