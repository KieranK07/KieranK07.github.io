Of course. Here is the complete, single-file code with all the requested functionality integrated: player cleanup on exit, and the core mechanics for shooting, health, damage, and respawning.

```html
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Multiplayer FPS Demo | Three.js & Firestore</title>

<script src="https://cdn.tailwindcss.com"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script src="https://www.gstatic.com/firebasejs/11.6.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/11.6.1/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore-compat.js"></script>

<style>
  /* Minimal styling (kept from original) */
  body, html { margin: 0; height: 100%; overflow: hidden; background:#0f172a; color:#f8fafc; font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; }
  #game-container { position:absolute; inset:0; z-index:1; }
  #ui-overlay { position:fixed; inset:0; pointer-events:none; z-index:10; }
  #crosshair { position:absolute; top:50%; left:50%; width:20px; height:20px; margin:-10px 0 0 -10px; border-radius:50%; border:2px solid #2dd4bf; box-shadow:0 0 5px #2dd4bf; pointer-events:none; }
  #instructions { position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); background:rgba(15,23,42,0.95); border:2px solid #2dd4bf; padding:3rem 4rem; text-align:center; border-radius:1rem; box-shadow:0 0 40px rgba(45,212,191,0.4); pointer-events:all; min-width:320px; }
  .hud { position:fixed; top:1rem; left:1rem; pointer-events:auto; z-index:11; }
</style>
</head>
<body class="font-mono">
  <div id="game-container"></div>

  <div id="ui-overlay">
    <div id="crosshair"></div>

    <div class="hud">
      <div class="bg-primary-dark/70 rounded-lg p-2 text-xs">
        <p id="fps-display">FPS: 0</p>
        <p id="health-display" class="text-green-400">Health: 100</p>
        <p id="player-count-display">Players: 1</p>
        <p id="user-id-display" class="break-words max-w-[220px]">User ID: Connecting...</p>
        <p id="status-message" class="text-red-400 mt-1"></p>
      </div>
    </div>

    <div id="instructions">
      <h1 class="text-4xl font-bold text-accent-neon mb-6">SYSTEM BOOT SEQUENCE</h1>
      <p class="text-gray-400 mb-6">Secure connection established. Initiating multi-user protocol...</p>
      <button id="start-button" class="px-10 py-4 bg-accent-blue text-primary-dark text-lg font-extrabold rounded-full hover:bg-sky-300 transition duration-300 pointer-events-auto">
        ENTER THE GRID
      </button>
    </div>
  </div>

<script>
/*
  FULL Single-file Multiplayer FPS for static hosting (GitHub Pages).
  - Uses Firebase compat (v11) SDKs so no bundler required.
  - Replace the firebaseConfig object below with your project's config.
  - Ensure Firestore rules permit authenticated users to read/write the fps_players path.
*/

/* ===== FIREBASE CONFIG =====
    Replace values with your project's web config from Console -> Project settings -> SDK setup.
*/
const firebaseConfig = {
  apiKey: "AIzaSyAZ5Xc4Hl1_bN9KLf8S32OxSH_P6JOZwx0",
  authDomain: "fpsmult-5f414.firebaseapp.com",
  projectId: "fpsmult-5f414",
  storageBucket: "fpsmult-5f414.firebasestorage.app",
  messagingSenderId: "353781130843",
  appId: "1:353781130843:web:3a04c9d1f49b52f153417e"
};

/* ===== INIT FIREBASE ===== */
firebase.initializeApp(firebaseConfig);
const auth = firebase.auth();
const db = firebase.firestore();
firebase.firestore.setLogLevel && firebase.firestore.setLogLevel("debug"); // optional

/* ===== GLOBAL VARS (GAME + MULTIPLAYER) ===== */
const appId = "default-app-id"; // change if you want per-project artifact grouping
let PLAYER_ID = null;
let gameCollectionRef = null; // firestore collection reference: artifacts/{appId}/public/data/fps_players
let playerDocRef = null;

let scene, camera, renderer, clock;
let playerObject;
const otherPlayers = {};
let isLocked = false;

const PLAYER_HEIGHT = 12;
const PLAYER_HALF_HEIGHT = PLAYER_HEIGHT / 2;
const MOVE_SPEED = 120;
const JUMP_SPEED = 150;
const GRAVITY = 9.8 * 30;
const PLAYER_SYNC_RATE = 100; // ms
let lastSyncTime = 0;
let canJump = false;
let isDead = false;
let respawnTimer = 0;
const RESPAWN_POSITION = new THREE.Vector3(0, PLAYER_HALF_HEIGHT + 0.1, 0);

const ARENA_SIZE = 400;
const HALF_ARENA = ARENA_SIZE / 2;
const PLATFORMS_DATA = [
  { pos: new THREE.Vector3(0, -2.5, 0), size: new THREE.Vector3(ARENA_SIZE, 5, ARENA_SIZE), color: 0x101a2c, opacity: 1 },
];

let raycaster;
let collidableObjects = [];
const keyState = { w:false, a:false, s:false, d:false, space:false };
const velocity = new THREE.Vector3();
const direction = new THREE.Vector3();

let localPlayerState = { health: 100 };
const DAMAGE = 25;

/* DOM */
const gameContainer = document.getElementById('game-container');
const fpsDisplay = document.getElementById('fps-display');
const playerCountDisplay = document.getElementById('player-count-display');
const userIdDisplay = document.getElementById('user-id-display');
const statusMessage = document.getElementById('status-message');
const startButton = document.getElementById('start-button');
const instructionsPanel = document.getElementById('instructions');

/* ===== PLAYER CLEANUP ON EXIT ===== */
window.addEventListener('beforeunload', async (event) => {
  if (playerDocRef) {
    try {
      await playerDocRef.delete();
    } catch (e) {
      console.error('Could not delete player document on exit:', e);
    }
  }
});

/* ===== FIRESTORE HELPERS ===== */
function getGameCollectionRefs() {
  const artifacts = db.collection('artifacts').doc(appId);
  const publicDoc = artifacts.collection('public').doc('data');
  const playersColl = publicDoc.collection('fps_players');
  return { playersColl };
}

async function retryOperation(apiCall, maxRetries = 5, baseDelay = 100) {
  for (let i=0;i<maxRetries;i++){
    try { return await apiCall(); }
    catch (err) {
      if (i === maxRetries-1) throw err;
      await new Promise(r => setTimeout(r, baseDelay * Math.pow(2, i)));
    }
  }
}

/* ===== SYNC: write local player state to Firestore ===== */
async function syncLocalPlayerState() {
  if (!PLAYER_ID || !playerObject || !playerDocRef || isDead) return;
  const now = Date.now();
  if (now - lastSyncTime < PLAYER_SYNC_RATE) return;
  lastSyncTime = now;

  const playerState = {
    id: PLAYER_ID,
    position: { x: playerObject.position.x, y: playerObject.position.y, z: playerObject.position.z },
    rotation: { x: camera.rotation.x, y: playerObject.rotation.y, z: 0 },
    isDead,
    health: localPlayerState.health,
    timestamp: firebase.firestore.FieldValue.serverTimestamp()
  };

  try {
    await retryOperation(() => playerDocRef.set(playerState, { merge:true }));
  } catch (err) {
    console.error("Write error:", err);
    statusMessage.textContent = 'Sync Error. Check console.';
  }
}

/* ===== LISTENER: observe other players ===== */
function setupMultiplayerListener() {
  if (!gameCollectionRef) return;

  const selfDocRef = gameCollectionRef.doc(PLAYER_ID);
  selfDocRef.onSnapshot(doc => {
      if (!doc.exists) return;
      const data = doc.data();
      localPlayerState.health = data.health;

      const healthDisplay = document.getElementById('health-display');
      healthDisplay.textContent = `Health: ${Math.round(localPlayerState.health)}`;
      healthDisplay.style.color = localPlayerState.health < 50 ? '#f87171' : '#4ade80';

      if (localPlayerState.health <= 0 && !isDead) {
          isDead = true;
          respawnTimer = 5000;
          velocity.set(0, 0, 0);
          statusMessage.classList.remove('text-red-400');
          statusMessage.classList.add('text-accent-neon');
          statusMessage.textContent = "SYSTEM FAILURE: Terminated. Respawning in 5.0s...";
      }
  });

  gameCollectionRef.onSnapshot(snapshot => {
    snapshot.docChanges().forEach(change => {
      const id = change.doc.id;
      const data = change.doc.data();
      if (id === PLAYER_ID) return;

      if (change.type === "added" || change.type === "modified") {
        updateOtherPlayer(id, data);
      } else if (change.type === "removed") {
        removeOtherPlayer(id);
      }
    });

    playerCountDisplay.textContent = `Players: ${Object.keys(otherPlayers).length + (PLAYER_ID?1:0)}`;
  }, err => {
    console.error("Listen error:", err);
    statusMessage.textContent = 'Live Data Error. Check console.';
  });
}

function updateOtherPlayer(id, data) {
  if (!data) return;
  let entry = otherPlayers[id];
  if (!entry) {
    const geometry = new THREE.BoxGeometry(5, PLAYER_HEIGHT, 5);
    const randomColor = new THREE.Color(Math.random() * 0xffffff);
    const material = new THREE.MeshBasicMaterial({ color: randomColor, transparent:true, opacity:0.9 });
    const mesh = new THREE.Mesh(geometry, material);
    mesh.userData.playerId = id;

    const tagText = 'P-'+id.substring(0,4);
    const spriteMap = new THREE.TextureLoader().load(`https://placehold.co/128x32/1e293b/00ffaa?text=${encodeURIComponent(tagText)}`);
    const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: spriteMap }));
    sprite.scale.set(10,2.5,1);
    sprite.position.set(0, PLAYER_HALF_HEIGHT + 1, 0);
    mesh.add(sprite);

    scene.add(mesh);
    otherPlayers[id] = { mesh, data, originalColor: randomColor };
  } else {
    if (data.health < entry.data.health) {
        entry.mesh.material.color.set(0xff0000);
        setTimeout(() => {
            if(otherPlayers[id]) {
               otherPlayers[id].mesh.material.color.copy(otherPlayers[id].originalColor);
            }
        }, 150);
    }
  }

  const mesh = otherPlayers[id].mesh;
  mesh.position.set(data.position.x, data.position.y, data.position.z);
  mesh.rotation.y = (data.rotation && data.rotation.y) || 0;
  otherPlayers[id].data = data;

  if (data.isDead || data.health <= 0) {
    mesh.visible = false;
  } else {
    mesh.visible = true;
  }
}

function removeOtherPlayer(id) {
  const entry = otherPlayers[id];
  if (!entry) return;
  scene.remove(entry.mesh);
  delete otherPlayers[id];
}

/* ===== THREE.JS SETUP ===== */
function init() {
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0f172a);
  scene.fog = new THREE.Fog(0x0f172a, 10, 400);

  camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.5, 1000);
  camera.position.set(0, PLAYER_HALF_HEIGHT, 0);

  playerObject = new THREE.Object3D();
  playerObject.position.copy(RESPAWN_POSITION);
  scene.add(playerObject);
  playerObject.add(camera);

  renderer = new THREE.WebGLRenderer({ antialias:true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  gameContainer.appendChild(renderer.domElement);

  raycaster = new THREE.Raycaster();
  raycaster.ray.direction.set(0, -1, 0);

  const ambient = new THREE.AmbientLight(0xaaaaaa, 0.8); scene.add(ambient);
  const dir = new THREE.DirectionalLight(0xffffff, 4); dir.position.set(200,300,200); scene.add(dir);

  const gridHelper = new THREE.GridHelper(ARENA_SIZE, ARENA_SIZE/10, 0x38bdf8, 0x00ffaa);
  gridHelper.material.opacity = 0.5; gridHelper.material.transparent = true; gridHelper.position.y = 0; scene.add(gridHelper);

  const boxGeom = new THREE.BoxGeometry(1,1,1);
  PLATFORMS_DATA.forEach(d => {
    const mat = new THREE.MeshLambertMaterial({ color:d.color, transparent: d.opacity<1, opacity:d.opacity });
    const m = new THREE.Mesh(boxGeom, mat);
    m.scale.set(d.size.x, d.size.y, d.size.z);
    m.position.copy(d.pos);
    scene.add(m);
    collidableObjects.push(m);
  });

  window.addEventListener('resize', onWindowResize, false);
}

function onWindowResize() {
  if (!camera || !renderer) return;
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

/* ===== INPUT / CONTROLS ===== */
function setupControls() {
  document.addEventListener('pointerlockchange', lockChangeAlert, false);
  document.addEventListener('mozpointerlockchange', lockChangeAlert, false);

  gameContainer.addEventListener('click', () => {
    gameContainer.requestPointerLock && gameContainer.requestPointerLock();
  });
  
  gameContainer.addEventListener('mousedown', (event) => {
    if (isLocked && event.button === 0) { // Left mouse button
        shoot();
    }
  });

  function lockChangeAlert(){
    if (document.pointerLockElement === gameContainer || document.mozPointerLockElement === gameContainer){
      isLocked = true; instructionsPanel.style.display = 'none'; document.addEventListener('mousemove', onMouseMove, false);
    } else {
      isLocked = false; instructionsPanel.style.display = 'block'; document.removeEventListener('mousemove', onMouseMove, false);
    }
  }

  const sensitivity = 0.002;
  function onMouseMove(e){
    if (!isLocked) return;
    const mx = e.movementX || e.mozMovementX || 0;
    const my = e.movementY || e.mozMovementY || 0;
    playerObject.rotation.y -= mx * sensitivity;
    let newPitch = camera.rotation.x - my * sensitivity;
    newPitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, newPitch));
    camera.rotation.x = newPitch;
  }

  document.addEventListener('keydown', (ev) => {
    if (!isLocked || isDead) return;
    switch(ev.code){
      case 'KeyW': keyState.w = true; break;
      case 'KeyA': keyState.a = true; break;
      case 'KeyS': keyState.s = true; break;
      case 'KeyD': keyState.d = true; break;
      case 'Space': if (canJump) { velocity.y = JUMP_SPEED; canJump = false; } break;
    }
  });

  document.addEventListener('keyup', (ev) => {
    if (!isLocked) return;
    switch(ev.code){
      case 'KeyW': keyState.w = false; break;
      case 'KeyA': keyState.a = false; break;
      case 'KeyS': keyState.s = false; break;
      case 'KeyD': keyState.d = false; break;
    }
  });
}

/* ===== SHOOTING LOGIC ===== */
async function handleShoot(targetId) {
    if (!targetId) return;
    const targetPlayerRef = gameCollectionRef.doc(targetId);
    try {
        await db.runTransaction(async (transaction) => {
            const targetDoc = await transaction.get(targetPlayerRef);
            if (!targetDoc.exists) { return; }
            const currentHealth = targetDoc.data().health || 0;
            const newHealth = Math.max(0, currentHealth - DAMAGE);
            transaction.update(targetPlayerRef, { health: newHealth });
        });
    } catch (e) {
        console.error("Transaction failure:", e);
        statusMessage.textContent = 'Damage sync failed.';
    }
}

function shoot() {
    if (!isLocked || isDead) return;
    const shootRaycaster = new THREE.Raycaster();
    shootRaycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
    const otherPlayerMeshes = Object.values(otherPlayers).map(p => p.mesh);
    const intersects = shootRaycaster.intersectObjects(otherPlayerMeshes, true); // Set recursive to true
    if (intersects.length > 0) {
        let targetMesh = intersects[0].object;
        while (targetMesh.parent && !targetMesh.userData.playerId) {
            targetMesh = targetMesh.parent;
        }
        if (targetMesh.userData.playerId) {
            handleShoot(targetMesh.userData.playerId);
        }
    }
}

/* ===== MOVEMENT, PHYSICS, DEATH ===== */
function updateMovement(delta) {
  if (!isLocked || isDead) return;

  velocity.y -= GRAVITY * delta;
  playerObject.position.y += velocity.y * delta;

  raycaster.ray.origin.copy(playerObject.position);
  raycaster.ray.origin.y += 0.1;
  raycaster.far = PLAYER_HALF_HEIGHT + 0.1;

  const intersections = raycaster.intersectObjects(collidableObjects, false);
  if (intersections.length > 0) {
    const hit = intersections[0];
    const distanceToHit = hit.distance;
    if (velocity.y <= 0 && distanceToHit <= PLAYER_HALF_HEIGHT + 0.1) {
      const desiredCenterY = hit.point.y + PLAYER_HALF_HEIGHT;
      playerObject.position.y = desiredCenterY;
      velocity.y = 0;
      canJump = true;
    }
  } else { canJump = false; }

  const actualMoveSpeed = MOVE_SPEED * delta;
  direction.x = 0; direction.z = 0;
  if (keyState.w) direction.z -= 1;
  if (keyState.s) direction.z += 1;
  if (keyState.a) direction.x -= 1;
  if (keyState.d) direction.x += 1;

  if (direction.x !== 0 || direction.z !== 0) {
    direction.normalize();
    const forward = new THREE.Vector3(0,0,direction.z).applyEuler(playerObject.rotation).multiplyScalar(actualMoveSpeed);
    const right = new THREE.Vector3(direction.x,0,0).applyEuler(playerObject.rotation).multiplyScalar(actualMoveSpeed);
    playerObject.position.x += forward.x + right.x;
    playerObject.position.z += forward.z + right.z;
  }

  const playerHalfSizeHorizontal = 2.5;
  const wallBoundary = HALF_ARENA - playerHalfSizeHorizontal - 0.5;
  playerObject.position.x = Math.max(-wallBoundary, Math.min(wallBoundary, playerObject.position.x));
  playerObject.position.z = Math.max(-wallBoundary, Math.min(wallBoundary, playerObject.position.z));
}

function handleDeathAndRespawn(delta) {
  if (!playerObject) return;
  if (!isDead && playerObject.position.y - PLAYER_HALF_HEIGHT < -50) {
    isDead = true; respawnTimer = 5000; velocity.set(0,0,0);
    localPlayerState.health = 0;
    statusMessage.classList.remove('text-red-400'); statusMessage.classList.add('text-accent-neon');
    statusMessage.textContent = "FATAL ERROR: Fall detected. Respawning in 5.0s...";
  }

  if (isDead) {
    respawnTimer -= delta * 1000;
    if (respawnTimer <= 0) {
      isDead = false;
      playerObject.position.copy(RESPAWN_POSITION);
      velocity.set(0,0,0); canJump = true;
      localPlayerState.health = 100;
      statusMessage.textContent = ""; statusMessage.classList.add('text-red-400');
    } else {
      const seconds = (respawnTimer/1000).toFixed(1);
      const deathMessage = localPlayerState.health > 0 && playerObject.position.y - PLAYER_HALF_HEIGHT < -50 ?
          `FATAL ERROR: Fall detected. Respawning in ${seconds}s...` :
          `SYSTEM FAILURE: Terminated. Respawning in ${seconds}s...`;
      statusMessage.textContent = deathMessage;
    }
  }
}

/* ===== ANIMATION LOOP ===== */
function animate() {
  requestAnimationFrame(animate);
  const delta = clock.getDelta();
  const fps = 1 / delta;
  fpsDisplay.textContent = `FPS: ${Math.round(fps)}`;

  handleDeathAndRespawn(delta);
  if (isLocked) updateMovement(delta);

  syncLocalPlayerState();
  renderer.render(scene, camera);
}

/* ===== GAME START / AUTH ===== */
async function setupAuthAndStartGame() {
  statusMessage.textContent = 'Authenticating...';
  try {
    const cred = await auth.signInAnonymously();
    PLAYER_ID = cred.user.uid;
    userIdDisplay.textContent = `User ID: ${PLAYER_ID}`;

    const { playersColl } = getGameCollectionRefs();
    gameCollectionRef = playersColl;
    playerDocRef = playersColl.doc(PLAYER_ID);

    await playerDocRef.set({
      id: PLAYER_ID,
      position: { x: RESPAWN_POSITION.x, y: RESPAWN_POSITION.y, z: RESPAWN_POSITION.z },
      rotation: { x: camera ? camera.rotation.x : 0, y: 0, z: 0 },
      isDead: false,
      health: 100,
      timestamp: firebase.firestore.FieldValue.serverTimestamp()
    }, { merge:true });

    init();
    setupControls();
    setupMultiplayerListener();
    clock = new THREE.Clock();
    animate();
    statusMessage.textContent = '';
  } catch (err) {
    console.error("Auth/start error:", err);
    statusMessage.textContent = 'Auth failed. Check console and Firebase config.';
  }
}

/* ===== ENTRY POINT BINDING ===== */
window.onload = () => {
  startButton.disabled = true;
  statusMessage.classList.remove('text-red-400');
  statusMessage.classList.add('text-gray-400');
  statusMessage.textContent = 'Initializing Firebase...';

  const checkReady = () => {
    if (typeof firebase !== 'undefined' && typeof db !== 'undefined' && typeof auth !== 'undefined') {
      startButton.disabled = false;
      statusMessage.textContent = 'Ready to enter the grid.';
      statusMessage.classList.remove('text-gray-400');
      statusMessage.classList.add('text-red-400');
      startButton.addEventListener('click', setupAuthAndStartGame);
    } else {
      setTimeout(checkReady, 100);
    }
  };
  setTimeout(checkReady, 50);
};
</script>
</body>
</html>
```