<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Multiplayer Demo | Three.js & Firestore</title>

<script src="https://cdn.tailwindcss.com"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script src="https://www.gstatic.com/firebasejs/11.6.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/11.6.1/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore-compat.js"></script>

<style>
  /* Minimal styling */
  body, html { margin: 0; height: 100%; overflow: hidden; background:#0f172a; color:#f8fafc; font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; }
  #game-container { position:absolute; inset:0; z-index:1; }
  #ui-overlay { position:fixed; inset:0; pointer-events:none; z-index:10; }
  #crosshair { position:absolute; top:50%; left:50%; width:20px; height:20px; margin:-10px 0 0 -10px; border-radius:50%; border:2px solid #2dd4bf; box-shadow:0 0 5px #2dd4bf; pointer-events:none; }
  #instructions { position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); background:rgba(15,23,42,0.95); border:2px solid #2dd4bf; padding:3rem 4rem; text-align:center; border-radius:1rem; box-shadow:0 0 40px rgba(45,212,191,0.4); pointer-events:all; min-width:320px; }
  .hud { position:fixed; top:1rem; left:1rem; pointer-events:auto; z-index:11; }
  .name-input { pointer-events:auto; background: #1e293b; border: 1px solid #38bdf8; color: #f8fafc; padding: 0.5rem 1rem; border-radius: 0.25rem; margin-bottom: 1.5rem; text-align: center; }
</style>
</head>
<body class="font-mono">
  <div id="game-container"></div>

  <div id="ui-overlay">
    <div id="crosshair"></div>

    <div class="hud">
      <div class="bg-primary-dark/70 rounded-lg p-2 text-xs">
        <p id="fps-display">FPS: 0</p>
        <p id="player-count-display">Players: 1</p>
        <p id="user-id-display" class="break-words max-w-[220px]">User ID: Connecting...</p>
        <p id="status-message" class="text-red-400 mt-1"></p>
      </div>
    </div>

    <div id="instructions">
      <h1 class="text-4xl font-bold text-accent-neon mb-4">SYSTEM BOOT SEQUENCE</h1>
      <p class="text-gray-400 mb-6">Enter your callsign to establish connection.</p>
      <input type="text" id="name-input" class="name-input" placeholder="Enter Name" maxlength="12">
      <br>
      <button id="start-button" class="px-10 py-4 bg-accent-blue text-primary-dark text-lg font-extrabold rounded-full hover:bg-sky-300 transition duration-300 pointer-events-auto">
        ENTER THE GRID
      </button>
    </div>
  </div>

<script>
/* ===== FIREBASE CONFIG ===== */
const firebaseConfig = {
  apiKey: "AIzaSyAZ5Xc4Hl1_bN9KLf8S32OxSH_P6JOZwx0",
  authDomain: "fpsmult-5f414.firebaseapp.com",
  projectId: "fpsmult-5f414",
  storageBucket: "fpsmult-5f414.firebasestorage.app",
  messagingSenderId: "353781130843",
  appId: "1:353781130843:web:3a04c9d1f49b52f153417e"
};

/* ===== INIT FIREBASE ===== */
firebase.initializeApp(firebaseConfig);
const auth = firebase.auth();
const db = firebase.firestore();

/* ===== GLOBAL VARS ===== */
const appId = "default-app-id";
let PLAYER_ID = null;
let gameCollectionRef = null;
let playerDocRef = null;

let scene, camera, renderer, clock;
let playerObject, headMesh;
const otherPlayers = {};
let isLocked = false;

const PLAYER_HEIGHT = 12;
const PLAYER_RADIUS = 2;
const PLAYER_HALF_HEIGHT = PLAYER_HEIGHT / 2;
const MOVE_SPEED = 120;
const JUMP_SPEED = 150;
const GRAVITY = 9.8 * 30;
const PLAYER_SYNC_RATE = 100;
let lastSyncTime = 0;
let canJump = false;
let isDead = false;
let respawnTimer = 0;
const RESPAWN_POSITION = new THREE.Vector3(0, 10, 0);

const ARENA_SIZE = 400;

const PLATFORMS_DATA = [
    { pos: new THREE.Vector3(0, -2.5, 0), size: new THREE.Vector3(ARENA_SIZE, 5, ARENA_SIZE), color: 0x101a2c },
    { pos: new THREE.Vector3(0, 2.5, 0), size: new THREE.Vector3(60, 5, 60), color: 0x1e293b },
    { pos: new THREE.Vector3(0, 32.5, -100), size: new THREE.Vector3(50, 5, 50), color: 0x1e293b },
    { pos: new THREE.Vector3(-45, 17.5, -50), size: new THREE.Vector3(20, 5, 120), color: 0x2dd4bf, rotation: new THREE.Euler(0, 0, -0.25) },
    { pos: new THREE.Vector3(45, 17.5, -50), size: new THREE.Vector3(20, 5, 120), color: 0x2dd4bf, rotation: new THREE.Euler(0, 0, 0.25) },
    { pos: new THREE.Vector3(-60, 20, -60), size: new THREE.Vector3(10, 40, 10), color: 0x00ffaa, opacity: 0.7 },
    { pos: new THREE.Vector3(60, 20, -60), size: new THREE.Vector3(10, 40, 10), color: 0x00ffaa, opacity: 0.7 },
    { pos: new THREE.Vector3(60, 20, 60), size: new THREE.Vector3(10, 40, 10), color: 0x00ffaa, opacity: 0.7 },
    { pos: new THREE.Vector3(-60, 20, 60), size: new THREE.Vector3(10, 40, 10), color: 0x00ffaa, opacity: 0.7 },
];

let raycaster;
let collidableObjects = [];
const keyState = { w:false, a:false, s:false, d:false, space:false };
const velocity = new THREE.Vector3();
const direction = new THREE.Vector3();

/* DOM */
const gameContainer = document.getElementById('game-container');
const fpsDisplay = document.getElementById('fps-display');
const playerCountDisplay = document.getElementById('player-count-display');
const userIdDisplay = document.getElementById('user-id-display');
const statusMessage = document.getElementById('status-message');
const startButton = document.getElementById('start-button');
const instructionsPanel = document.getElementById('instructions');
const nameInput = document.getElementById('name-input');

/* ===== PLAYER CLEANUP ON EXIT ===== */
window.addEventListener('beforeunload', async () => {
  if (playerDocRef) { await playerDocRef.delete(); }
});

/* ===== FIRESTORE HELPERS ===== */
function getGameCollectionRefs() {
  const artifacts = db.collection('artifacts').doc(appId);
  const publicDoc = artifacts.collection('public').doc('data');
  const playersColl = publicDoc.collection('fps_players');
  return { playersColl };
}

/* ===== SYNC: write local player state to Firestore ===== */
async function syncLocalPlayerState() {
  if (!PLAYER_ID || !playerObject || !playerDocRef || isDead) return;
  const now = Date.now();
  if (now - lastSyncTime < PLAYER_SYNC_RATE) return;
  lastSyncTime = now;

  const playerState = {
    id: PLAYER_ID,
    playerName: nameInput.value || 'Anon',
    position: { x: playerObject.position.x, y: playerObject.position.y, z: playerObject.position.z },
    rotation: { x: headMesh.rotation.x, y: playerObject.rotation.y, z: 0 },
    isDead,
    timestamp: firebase.firestore.FieldValue.serverTimestamp()
  };

  try {
    await playerDocRef.set(playerState, { merge:true });
  } catch (err) { console.error("Write error:", err); }
}

/* ===== LISTENERS AND INTERPOLATION ===== */
function setupMultiplayerListener() {
  if (!gameCollectionRef) return;
  gameCollectionRef.onSnapshot(snapshot => {
    snapshot.docChanges().forEach(change => {
      const id = change.doc.id;
      const data = change.doc.data();
      if (id === PLAYER_ID) return;

      if (change.type === "added") {
        addOtherPlayer(id, data);
      } else if (change.type === "modified") {
        updateOtherPlayerData(id, data);
      } else if (change.type === "removed") {
        removeOtherPlayer(id);
      }
    });
    playerCountDisplay.textContent = `Players: ${Object.keys(otherPlayers).length + (PLAYER_ID?1:0)}`;
  }, err => { console.error("Listen error:", err); });
}

function createPlayerModel(color = 0xffffff) {
    const playerGroup = new THREE.Group();
    
    const bodyGeom = new THREE.CapsuleGeometry(PLAYER_RADIUS, PLAYER_HEIGHT - (PLAYER_RADIUS * 2), 4, 16);
    const bodyMat = new THREE.MeshLambertMaterial({ color });
    const bodyMesh = new THREE.Mesh(bodyGeom, bodyMat);
    bodyMesh.position.y = PLAYER_HALF_HEIGHT;
    playerGroup.add(bodyMesh);

    const headGeom = new THREE.BoxGeometry(4, 4, 4);
    const headMat = new THREE.MeshLambertMaterial({ color: color - 0x222222 });
    const head = new THREE.Mesh(headGeom, headMat);
    head.position.y = PLAYER_HEIGHT + 2;
    playerGroup.add(head);

    return { playerGroup, head };
}

function addOtherPlayer(id, data) {
    const { playerGroup, head } = createPlayerModel(Math.random() * 0xffffff);
    playerGroup.position.set(data.position.x, data.position.y, data.position.z);
    
    const playerName = data.playerName || 'Anon';
    const spriteMap = new THREE.TextureLoader().load(`https://placehold.co/128x32/1e293b/00ffaa?text=${encodeURIComponent(playerName)}`);
    const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: spriteMap }));
    sprite.scale.set(12, 3, 1);
    sprite.position.y = PLAYER_HEIGHT + 6;
    playerGroup.add(sprite);

    scene.add(playerGroup);

    otherPlayers[id] = {
        mesh: playerGroup,
        head: head,
        targetPosition: new THREE.Vector3().copy(playerGroup.position),
        targetBodyQuaternion: new THREE.Quaternion(),
        targetHeadPitch: 0,
    };
}

function updateOtherPlayerData(id, data) {
    const entry = otherPlayers[id];
    if (!entry || !data.position || !data.rotation) return;
    
    entry.targetPosition.set(data.position.x, data.position.y, data.position.z);
    
    const bodyEuler = new THREE.Euler(0, data.rotation.y, 0, 'YXZ');
    entry.targetBodyQuaternion.setFromEuler(bodyEuler);
    
    entry.targetHeadPitch = data.rotation.x;

    entry.mesh.visible = !data.isDead;
}

function removeOtherPlayer(id) {
  const entry = otherPlayers[id];
  if (!entry) return;
  scene.remove(entry.mesh);
  delete otherPlayers[id];
}

function updateRemotePlayers(delta) {
    const interpolationFactor = delta * 15;
    for (const id in otherPlayers) {
        const player = otherPlayers[id];
        player.mesh.position.lerp(player.targetPosition, interpolationFactor);
        player.mesh.quaternion.slerp(player.targetBodyQuaternion, interpolationFactor);
        player.head.rotation.x = THREE.MathUtils.lerp(player.head.rotation.x, player.targetHeadPitch, interpolationFactor);
    }
}

/* ===== THREE.JS SETUP ===== */
function init() {
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0f172a);
  scene.fog = new THREE.Fog(0x0f172a, 50, 450);

  camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.5, 1000);
  
  const { playerGroup, head } = createPlayerModel(0x2dd4bf);
  playerObject = playerGroup;
  headMesh = head;
  playerObject.position.copy(RESPAWN_POSITION);
  
  // THIS IS THE FIX: Start rotated 180 degrees to see the lobby
  playerObject.rotation.y = Math.PI;

  playerObject.traverse(child => { if (child.isMesh) child.visible = false; });
  
  headMesh.add(camera);
  scene.add(playerObject);

  renderer = new THREE.WebGLRenderer({ antialias:true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  gameContainer.appendChild(renderer.domElement);

  raycaster = new THREE.Raycaster();
  raycaster.ray.direction.set(0, -1, 0);

  const ambient = new THREE.AmbientLight(0xaaaaaa, 0.8); scene.add(ambient);
  const dir = new THREE.DirectionalLight(0xffffff, 4); dir.position.set(200,300,200); scene.add(dir);

  const gridHelper = new THREE.GridHelper(ARENA_SIZE, ARENA_SIZE/10, 0x38bdf8, 0x00ffaa);
  gridHelper.material.opacity = 0.5; gridHelper.material.transparent = true; gridHelper.position.y = 0; scene.add(gridHelper);

  const boxGeom = new THREE.BoxGeometry(1,1,1);
  PLATFORMS_DATA.forEach(d => {
    const mat = new THREE.MeshLambertMaterial({ color:d.color, transparent: d.opacity<1, opacity:d.opacity });
    const m = new THREE.Mesh(boxGeom, mat);
    m.scale.copy(d.size);
    m.position.copy(d.pos);
    if(d.rotation) m.rotation.copy(d.rotation);
    scene.add(m);
    collidableObjects.push(m);
  });

  window.addEventListener('resize', onWindowResize, false);
}

function onWindowResize() {
  if (!camera || !renderer) return;
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

/* ===== INPUT / CONTROLS ===== */
function setupControls() {
  document.addEventListener('pointerlockchange', lockChangeAlert, false);

  gameContainer.addEventListener('click', () => { gameContainer.requestPointerLock?.(); });

  function lockChangeAlert(){
    if (document.pointerLockElement === gameContainer){
      isLocked = true; instructionsPanel.style.display = 'none'; document.addEventListener('mousemove', onMouseMove, false);
    } else {
      isLocked = false; instructionsPanel.style.display = 'block'; document.removeEventListener('mousemove', onMouseMove, false);
    }
  }

  const sensitivity = 0.002;
  function onMouseMove(e){
    if (!isLocked) return;
    const mx = e.movementX || 0;
    const my = e.movementY || 0;
    
    playerObject.rotation.y -= mx * sensitivity;
    
    let newPitch = headMesh.rotation.x - my * sensitivity;
    headMesh.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, newPitch));
  }

  document.addEventListener('keydown', (ev) => {
    if (!isLocked || isDead) return;
    switch(ev.code){
      case 'KeyW': keyState.w = true; break;
      case 'KeyA': keyState.a = true; break;
      case 'KeyS': keyState.s = true; break;
      case 'KeyD': keyState.d = true; break;
      case 'Space': if (canJump) { velocity.y = JUMP_SPEED; canJump = false; } break;
    }
  });

  document.addEventListener('keyup', (ev) => {
    if (!isLocked) return;
    switch(ev.code){
      case 'KeyW': keyState.w = false; break;
      case 'KeyA': keyState.a = false; break;
      case 'KeyS': keyState.s = false; break;
      case 'KeyD': keyState.d = false; break;
    }
  });
}

/* ===== MOVEMENT, PHYSICS, DEATH ===== */
function updateMovement(delta) {
    if (!isLocked || isDead) return;

    velocity.y -= GRAVITY * delta;
    playerObject.position.y += velocity.y * delta;
    
    raycaster.ray.origin.copy(playerObject.position);
    raycaster.ray.origin.y += PLAYER_RADIUS; // Start raycast from center of capsule base
    raycaster.far = PLAYER_HALF_HEIGHT + PLAYER_RADIUS;

    const intersections = raycaster.intersectObjects(collidableObjects, false);
    let onGround = false;
    if (intersections.length > 0) {
        const hit = intersections[0];
        if (hit.distance < PLAYER_HALF_HEIGHT + 0.1) {
            if (velocity.y <= 0) {
                playerObject.position.y = hit.point.y + PLAYER_HALF_HEIGHT;
                velocity.y = 0;
                onGround = true;
                canJump = true;
            }
        }
    } else {
        canJump = false;
    }

    const actualMoveSpeed = MOVE_SPEED * delta;
    direction.z = Number(keyState.w) - Number(keyState.s);
    direction.x = Number(keyState.a) - Number(keyState.d);
    direction.normalize();

    if (keyState.w || keyState.s || keyState.a || keyState.d) {
        const moveVector = new THREE.Vector3(direction.x, 0, direction.z);
        moveVector.applyQuaternion(playerObject.quaternion);
        playerObject.position.add(moveVector.multiplyScalar(actualMoveSpeed));
    }
}


function handleDeathAndRespawn(delta) {
  if (!playerObject) return;
  if (!isDead && playerObject.position.y < -50) {
    isDead = true; respawnTimer = 5000; velocity.set(0,0,0);
    statusMessage.textContent = "FATAL ERROR: Fall detected. Respawning in 5.0s...";
  }

  if (isDead) {
    respawnTimer -= delta * 1000;
    if (respawnTimer <= 0) {
      isDead = false;
      playerObject.position.copy(RESPAWN_POSITION);
      playerObject.rotation.y = Math.PI; // Also reset rotation on respawn
      velocity.set(0,0,0); canJump = true;
      statusMessage.textContent = "";
    } else {
      const seconds = (respawnTimer/1000).toFixed(1);
      statusMessage.textContent = `FATAL ERROR: Fall detected. Respawning in ${seconds}s...`;
    }
  }
}

/* ===== ANIMATION LOOP ===== */
function animate() {
  requestAnimationFrame(animate);
  const delta = clock.getDelta();
  const fps = 1 / delta;
  fpsDisplay.textContent = `FPS: ${Math.round(fps)}`;

  handleDeathAndRespawn(delta);
  if (isLocked) updateMovement(delta);
  
  updateRemotePlayers(delta);

  syncLocalPlayerState();
  renderer.render(scene, camera);
}

/* ===== GAME START / AUTH ===== */
async function setupAuthAndStartGame() {
  if (nameInput.value.trim() === '') {
    statusMessage.textContent = 'Please enter a name.';
    return;
  }
  startButton.disabled = true;
  nameInput.disabled = true;
  statusMessage.textContent = 'Authenticating...';
  
  try {
    const cred = await auth.signInAnonymously();
    PLAYER_ID = cred.user.uid;
    userIdDisplay.textContent = `User ID: ${PLAYER_ID}`;

    const { playersColl } = getGameCollectionRefs();
    gameCollectionRef = playersColl;
    playerDocRef = playersColl.doc(PLAYER_ID);

    await playerDocRef.set({
      id: PLAYER_ID,
      playerName: nameInput.value,
      position: { x: RESPAWN_POSITION.x, y: RESPAWN_POSITION.y, z: RESPAWN_POSITION.z },
      rotation: { x: 0, y: Math.PI, z: 0 },
      isDead: false,
      timestamp: firebase.firestore.FieldValue.serverTimestamp()
    });

    init();
    setupControls();
    setupMultiplayerListener();
    clock = new THREE.Clock();
    animate();
    statusMessage.textContent = '';
  } catch (err) {
    console.error("Auth/start error:", err);
    statusMessage.textContent = 'Auth failed. Check console.';
    startButton.disabled = false;
    nameInput.disabled = false;
  }
}

/* ===== ENTRY POINT BINDING ===== */
window.onload = () => {
  startButton.disabled = true;
  statusMessage.textContent = 'Initializing Firebase...';
  
  const checkReady = () => {
    if (typeof firebase !== 'undefined' && typeof db !== 'undefined' && typeof auth !== 'undefined') {
      startButton.disabled = false;
      statusMessage.textContent = 'Ready to enter the grid.';
      startButton.addEventListener('click', setupAuthAndStartGame);
    } else {
      setTimeout(checkReady, 100);
    }
  };
  setTimeout(checkReady, 50);
};
</script>
</body>
</html>