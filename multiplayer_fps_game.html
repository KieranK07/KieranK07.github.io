<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Multiplayer Demo | Three.js & Firestore</title>

<script src="https://cdn.tailwindcss.com"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script src="https://www.gstatic.com/firebasejs/11.6.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/11.6.1/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore-compat.js"></script>

<style>
  /* Minimal styling */
  body, html { margin: 0; height: 100%; overflow: hidden; background:#0f172a; color:#f8fafc; font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; }
  #game-container { position:absolute; inset:0; z-index:1; }
  #ui-overlay { position:fixed; inset:0; pointer-events:none; z-index:10; }
  #crosshair { position:absolute; top:50%; left:50%; width:20px; height:20px; margin:-10px 0 0 -10px; border-radius:50%; border:2px solid #2dd4bf; box-shadow:0 0 5px #2dd4bf; pointer-events:none; }
  #instructions { position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); background:rgba(15,23,42,0.95); border:2px solid #2dd4bf; padding:3rem 4rem; text-align:center; border-radius:1rem; box-shadow:0 0 40px rgba(45,212,191,0.4); pointer-events:all; min-width:320px; }
  .hud { position:fixed; top:1rem; left:1rem; pointer-events:auto; z-index:11; }
  .name-input { pointer-events:auto; background: #1e293b; border: 1px solid #38bdf8; color: #f8fafc; padding: 0.5rem 1rem; border-radius: 0.25rem; margin-bottom: 1.5rem; text-align: center; }
</style>
</head>
<body class="font-mono">
  <div id="game-container"></div>

  <div id="ui-overlay">
    <div id="crosshair"></div>

    <div class="hud">
      <div class="bg-primary-dark/70 rounded-lg p-2 text-xs">
        <p id="fps-display">FPS: 0</p>
        <p id="player-count-display">Players: 1</p>
        <p id="user-id-display" class="break-words max-w-[220px]">User ID: Connecting...</p>
        <p id="status-message" class="text-red-400 mt-1"></p>
      </div>
    </div>

    <div id="instructions">
      <h1 class="text-4xl font-bold text-accent-neon mb-4">SYSTEM BOOT SEQUENCE</h1>
      <p class="text-gray-400 mb-6">Enter your callsign to establish connection.</p>
      <input type="text" id="name-input" class="name-input" placeholder="Enter Name" maxlength="12">
      <br>
      <button id="start-button" class="px-10 py-4 bg-accent-blue text-primary-dark text-lg font-extrabold rounded-full hover:bg-sky-300 transition duration-300 pointer-events-auto">
        ENTER THE GRID
      </button>
    </div>
  </div>

<script>
/* ===== FIREBASE CONFIG ===== */
const firebaseConfig = {
  apiKey: "AIzaSyAZ5Xc4Hl1_bN9KLf8S32OxSH_P6JOZwx0",
  authDomain: "fpsmult-5f414.firebaseapp.com",
  projectId: "fpsmult-5f414",
  storageBucket: "fpsmult-5f414.firebasestorage.app",
  messagingSenderId: "353781130843",
  appId: "1:353781130843:web:3a04c9d1f49b52f153417e"
};

/* ===== INIT FIREBASE ===== */
firebase.initializeApp(firebaseConfig);
const auth = firebase.auth();
const db = firebase.firestore();

/* ===== GLOBAL VARS ===== */
const appId = "default-app-id";
let PLAYER_ID = null;
let gameCollectionRef = null;
let playerDocRef = null;

let scene, camera, renderer, clock;
let playerObject;
const otherPlayers = {};
let isLocked = false;

const PLAYER_HEIGHT = 12;
const PLAYER_HALF_HEIGHT = PLAYER_HEIGHT / 2;
const MOVE_SPEED = 120;
const JUMP_SPEED = 150;
const GRAVITY = 9.8 * 30;
const PLAYER_SYNC_RATE = 100; // ms
let lastSyncTime = 0;
let canJump = false;
let isDead = false;
let respawnTimer = 0;
const RESPAWN_POSITION = new THREE.Vector3(0, PLAYER_HALF_HEIGHT + 0.1, 0);

const ARENA_SIZE = 400;
const HALF_ARENA = ARENA_SIZE / 2;
const PLATFORMS_DATA = [
  { pos: new THREE.Vector3(0, -2.5, 0), size: new THREE.Vector3(ARENA_SIZE, 5, ARENA_SIZE), color: 0x101a2c, opacity: 1 },
];

let raycaster;
let collidableObjects = [];
const keyState = { w:false, a:false, s:false, d:false, space:false };
const velocity = new THREE.Vector3();
const direction = new THREE.Vector3();

/* DOM */
const gameContainer = document.getElementById('game-container');
const fpsDisplay = document.getElementById('fps-display');
const playerCountDisplay = document.getElementById('player-count-display');
const userIdDisplay = document.getElementById('user-id-display');
const statusMessage = document.getElementById('status-message');
const startButton = document.getElementById('start-button');
const instructionsPanel = document.getElementById('instructions');
const nameInput = document.getElementById('name-input');

/* ===== PLAYER CLEANUP ON EXIT (CONFIRMED PRESENT) ===== */
window.addEventListener('beforeunload', async () => {
  if (playerDocRef) { await playerDocRef.delete(); }
});

/* ===== FIRESTORE HELPERS ===== */
function getGameCollectionRefs() {
  const artifacts = db.collection('artifacts').doc(appId);
  const publicDoc = artifacts.collection('public').doc('data');
  const playersColl = publicDoc.collection('fps_players');
  return { playersColl };
}

/* ===== SYNC: write local player state to Firestore ===== */
async function syncLocalPlayerState() {
  if (!PLAYER_ID || !playerObject || !playerDocRef || isDead) return;
  const now = Date.now();
  if (now - lastSyncTime < PLAYER_SYNC_RATE) return;
  lastSyncTime = now;

  const playerState = {
    id: PLAYER_ID,
    playerName: nameInput.value || 'Anon',
    position: { x: playerObject.position.x, y: playerObject.position.y, z: playerObject.position.z },
    rotation: { x: camera.rotation.x, y: playerObject.rotation.y, z: camera.rotation.z },
    isDead,
    timestamp: firebase.firestore.FieldValue.serverTimestamp()
  };

  try {
    await playerDocRef.set(playerState, { merge:true });
  } catch (err) {
    console.error("Write error:", err);
  }
}

/* ===== LISTENERS AND INTERPOLATION ===== */
function setupMultiplayerListener() {
  if (!gameCollectionRef) return;
  gameCollectionRef.onSnapshot(snapshot => {
    snapshot.docChanges().forEach(change => {
      const id = change.doc.id;
      const data = change.doc.data();
      if (id === PLAYER_ID) return;

      if (change.type === "added") {
        addOtherPlayer(id, data);
      } else if (change.type === "modified") {
        updateOtherPlayerData(id, data);
      } else if (change.type === "removed") {
        removeOtherPlayer(id);
      }
    });
    playerCountDisplay.textContent = `Players: ${Object.keys(otherPlayers).length + (PLAYER_ID?1:0)}`;
  }, err => {
    console.error("Listen error:", err);
  });
}

function addOtherPlayer(id, data) {
  const geometry = new THREE.BoxGeometry(5, PLAYER_HEIGHT, 5);
  const material = new THREE.MeshBasicMaterial({ color: Math.random()*0xffffff });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.position.set(data.position.x, data.position.y, data.position.z);

  const playerName = data.playerName || 'Anon';
  const spriteMap = new THREE.TextureLoader().load(`https://placehold.co/128x32/1e293b/00ffaa?text=${encodeURIComponent(playerName)}`);
  const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: spriteMap }));
  sprite.scale.set(10, 2.5, 1);
  sprite.position.set(0, PLAYER_HALF_HEIGHT + 1, 0);
  mesh.add(sprite);

  scene.add(mesh);
  otherPlayers[id] = {
    mesh,
    targetPosition: new THREE.Vector3().copy(mesh.position),
    targetQuaternion: new THREE.Quaternion().copy(mesh.quaternion)
  };
}

function updateOtherPlayerData(id, data) {
    const entry = otherPlayers[id];
    if (!entry || !data.position || !data.rotation) return;
    entry.targetPosition.set(data.position.x, data.position.y, data.position.z);
    
    const euler = new THREE.Euler(data.rotation.x, data.rotation.y, data.rotation.z, 'YXZ');
    entry.targetQuaternion.setFromEuler(euler);
    
    entry.mesh.visible = !data.isDead;
}

function removeOtherPlayer(id) {
  const entry = otherPlayers[id];
  if (!entry) return;
  scene.remove(entry.mesh);
  delete otherPlayers[id];
}

function updateRemotePlayers(delta) {
    const interpolationFactor = delta * 10;
    for (const id in otherPlayers) {
        const player = otherPlayers[id];
        player.mesh.position.lerp(player.targetPosition, interpolationFactor);
        player.mesh.quaternion.slerp(player.targetQuaternion, interpolationFactor);
    }
}

/* ===== THREE.JS SETUP ===== */
function init() {
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0f172a);
  scene.fog = new THREE.Fog(0x0f172a, 10, 400);

  camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.5, 1000);
  camera.position.set(0, PLAYER_HALF_HEIGHT, 0);

  playerObject = new THREE.Object3D();
  playerObject.position.copy(RESPAWN_POSITION);
  scene.add(playerObject);
  playerObject.add(camera);

  renderer = new THREE.WebGLRenderer({ antialias:true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  gameContainer.appendChild(renderer.domElement);

  raycaster = new THREE.Raycaster();
  raycaster.ray.direction.set(0, -1, 0);

  const ambient = new THREE.AmbientLight(0xaaaaaa, 0.8); scene.add(ambient);
  const dir = new THREE.DirectionalLight(0xffffff, 4); dir.position.set(200,300,200); scene.add(dir);

  const gridHelper = new THREE.GridHelper(ARENA_SIZE, ARENA_SIZE/10, 0x38bdf8, 0x00ffaa);
  gridHelper.material.opacity = 0.5; gridHelper.material.transparent = true; gridHelper.position.y = 0; scene.add(gridHelper);

  const boxGeom = new THREE.BoxGeometry(1,1,1);
  PLATFORMS_DATA.forEach(d => {
    const mat = new THREE.MeshLambertMaterial({ color:d.color, transparent: d.opacity<1, opacity:d.opacity });
    const m = new THREE.Mesh(boxGeom, mat);
    m.scale.set(d.size.x, d.size.y, d.size.z);
    m.position.copy(d.pos);
    scene.add(m);
    collidableObjects.push(m);
  });

  window.addEventListener('resize', onWindowResize, false);
}

function onWindowResize() {
  if (!camera || !renderer) return;
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

/* ===== INPUT / CONTROLS ===== */
function setupControls() {
  document.addEventListener('pointerlockchange', lockChangeAlert, false);

  gameContainer.addEventListener('click', () => {
    gameContainer.requestPointerLock && gameContainer.requestPointerLock();
  });

  function lockChangeAlert(){
    if (document.pointerLockElement === gameContainer){
      isLocked = true; instructionsPanel.style.display = 'none'; document.addEventListener('mousemove', onMouseMove, false);
    } else {
      isLocked = false; instructionsPanel.style.display = 'block'; document.removeEventListener('mousemove', onMouseMove, false);
    }
  }

  const sensitivity = 0.002;
  function onMouseMove(e){
    if (!isLocked) return;
    const mx = e.movementX || 0;
    const my = e.movementY || 0;
    playerObject.rotation.y -= mx * sensitivity;
    let newPitch = camera.rotation.x - my * sensitivity;
    newPitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, newPitch));
    camera.rotation.x = newPitch;
  }

  document.addEventListener('keydown', (ev) => {
    if (!isLocked || isDead) return;
    switch(ev.code){
      case 'KeyW': keyState.w = true; break;
      case 'KeyA': keyState.a = true; break;
      case 'KeyS': keyState.s = true; break;
      case 'KeyD': keyState.d = true; break;
      case 'Space': if (canJump) { velocity.y = JUMP_SPEED; canJump = false; } break;
    }
  });

  document.addEventListener('keyup', (ev) => {
    if (!isLocked) return;
    switch(ev.code){
      case 'KeyW': keyState.w = false; break;
      case 'KeyA': keyState.a = false; break;
      case 'KeyS': keyState.s = false; break;
      case 'KeyD': keyState.d = false; break;
    }
  });
}

/* ===== MOVEMENT, PHYSICS, DEATH ===== */
function updateMovement(delta) {
  if (!isLocked || isDead) return;

  velocity.y -= GRAVITY * delta;
  playerObject.position.y += velocity.y * delta;

  raycaster.ray.origin.copy(playerObject.position);
  raycaster.ray.origin.y += 0.1;
  raycaster.far = PLAYER_HALF_HEIGHT + 0.1;

  const intersections = raycaster.intersectObjects(collidableObjects, false);
  if (intersections.length > 0) {
    const hit = intersections[0];
    const distanceToHit = hit.distance;
    if (velocity.y <= 0 && distanceToHit <= PLAYER_HALF_HEIGHT + 0.1) {
      const desiredCenterY = hit.point.y + PLAYER_HALF_HEIGHT;
      playerObject.position.y = desiredCenterY;
      velocity.y = 0;
      canJump = true;
    }
  } else { canJump = false; }

  const actualMoveSpeed = MOVE_SPEED * delta;
  direction.x = 0; direction.z = 0;
  if (keyState.w) direction.z -= 1;
  if (keyState.s) direction.z += 1;
  if (keyState.a) direction.x -= 1;
  if (keyState.d) direction.x += 1;

  if (direction.x !== 0 || direction.z !== 0) {
    direction.normalize();
    const forward = new THREE.Vector3(0,0,direction.z).applyEuler(playerObject.rotation).multiplyScalar(actualMoveSpeed);
    const right = new THREE.Vector3(direction.x,0,0).applyEuler(playerObject.rotation).multiplyScalar(actualMoveSpeed);
    playerObject.position.x += forward.x + right.x;
    playerObject.position.z += forward.z + right.z;
  }

  const playerHalfSizeHorizontal = 2.5;
  const wallBoundary = HALF_ARENA - playerHalfSizeHorizontal - 0.5;
  playerObject.position.x = Math.max(-wallBoundary, Math.min(wallBoundary, playerObject.position.x));
  playerObject.position.z = Math.max(-wallBoundary, Math.min(wallBoundary, playerObject.position.z));
}

function handleDeathAndRespawn(delta) {
  if (!playerObject) return;
  if (!isDead && playerObject.position.y - PLAYER_HALF_HEIGHT < -50) {
    isDead = true; respawnTimer = 5000; velocity.set(0,0,0);
    statusMessage.textContent = "FATAL ERROR: Fall detected. Respawning in 5.0s...";
  }

  if (isDead) {
    respawnTimer -= delta * 1000;
    if (respawnTimer <= 0) {
      isDead = false;
      playerObject.position.copy(RESPAWN_POSITION);
      velocity.set(0,0,0); canJump = true;
      statusMessage.textContent = "";
    } else {
      const seconds = (respawnTimer/1000).toFixed(1);
      statusMessage.textContent = `FATAL ERROR: Fall detected. Respawning in ${seconds}s...`;
    }
  }
}

/* ===== ANIMATION LOOP ===== */
function animate() {
  requestAnimationFrame(animate);
  const delta = clock.getDelta();
  const fps = 1 / delta;
  fpsDisplay.textContent = `FPS: ${Math.round(fps)}`;

  handleDeathAndRespawn(delta);
  if (isLocked) updateMovement(delta);
  
  updateRemotePlayers(delta);

  syncLocalPlayerState();
  renderer.render(scene, camera);
}

/* ===== GAME START / AUTH ===== */
async function setupAuthAndStartGame() {
  if (nameInput.value.trim() === '') {
    statusMessage.textContent = 'Please enter a name.';
    return;
  }
  startButton.disabled = true;
  nameInput.disabled = true;
  statusMessage.textContent = 'Authenticating...';
  
  try {
    const cred = await auth.signInAnonymously();
    PLAYER_ID = cred.user.uid;
    userIdDisplay.textContent = `User ID: ${PLAYER_ID}`;

    const { playersColl } = getGameCollectionRefs();
    gameCollectionRef = playersColl;
    playerDocRef = playersColl.doc(PLAYER_ID);

    await playerDocRef.set({
      id: PLAYER_ID,
      playerName: nameInput.value,
      position: { x: RESPAWN_POSITION.x, y: RESPAWN_POSITION.y, z: RESPAWN_POSITION.z },
      rotation: { x: 0, y: 0, z: 0 },
      isDead: false,
      timestamp: firebase.firestore.FieldValue.serverTimestamp()
    });

    init();
    setupControls();
    setupMultiplayerListener();
    clock = new THREE.Clock();
    animate();
    statusMessage.textContent = '';
  } catch (err) {
    console.error("Auth/start error:", err);
    statusMessage.textContent = 'Auth failed. Check console.';
    startButton.disabled = false;
    nameInput.disabled = false;
  }
}

/* ===== ENTRY POINT BINDING (FIXED) ===== */
window.onload = () => {
  startButton.disabled = true;
  statusMessage.textContent = 'Initializing Firebase...';

  // This check ensures Firebase is loaded before the button is enabled.
  const checkReady = () => {
    if (typeof firebase !== 'undefined' && typeof db !== 'undefined' && typeof auth !== 'undefined') {
      startButton.disabled = false;
      statusMessage.textContent = 'Ready to enter the grid.';
      startButton.addEventListener('click', setupAuthAndStartGame);
    } else {
      setTimeout(checkReady, 100);
    }
  };
  setTimeout(checkReady, 50);
};
</script>
</body>
</html>