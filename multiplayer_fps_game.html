<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Multiplayer Demo | Physics Engine</title>

<script src="https://cdn.tailwindcss.com"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script src="https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.min.js"></script>


<script src="https://www.gstatic.com/firebasejs/11.6.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/11.6.1/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore-compat.js"></script>

<style>
  body, html { margin: 0; height: 100%; overflow: hidden; background:#0f172a; color:#f8fafc; font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; }
  #game-container { position:absolute; inset:0; z-index:1; }
  #ui-overlay { position:fixed; inset:0; pointer-events:none; z-index:10; }
  #crosshair { position:absolute; top:50%; left:50%; width:20px; height:20px; margin:-10px 0 0 -10px; border-radius:50%; border:2px solid #2dd4bf; box-shadow:0 0 5px #2dd4bf; pointer-events:none; }
  #instructions { position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); background:rgba(15,23,42,0.95); border:2px solid #2dd4bf; padding:3rem 4rem; text-align:center; border-radius:1rem; box-shadow:0 0 40px rgba(45,212,191,0.4); pointer-events:all; min-width:320px; }
  .hud { position:fixed; top:1rem; left:1rem; pointer-events:auto; z-index:11; }
  .name-input { pointer-events:auto; background: #1e293b; border: 1px solid #38bdf8; color: #f8fafc; padding: 0.5rem 1rem; border-radius: 0.25rem; margin-bottom: 1.5rem; text-align: center; }
</style>
</head>
<body class="font-mono">
  <div id="game-container"></div>

  <div id="ui-overlay">
    <div id="crosshair"></div>

    <div class="hud">
      <div class="bg-primary-dark/70 rounded-lg p-2 text-xs">
        <p id="fps-display">FPS: 0</p>
        <p id="player-count-display">Players: 1</p>
        <p id="user-id-display" class="break-words max-w-[220px]">User ID: Connecting...</p>
        <p id="status-message" class="text-red-400 mt-1"></p>
      </div>
    </div>

    <div id="instructions">
      <h1 class="text-4xl font-bold text-accent-neon mb-4">SYSTEM BOOT SEQUENCE</h1>
      <p class="text-gray-400 mb-6">Enter your callsign to establish connection.</p>
      <input type="text" id="name-input" class="name-input" placeholder="Enter Name" maxlength="12">
      <br>
      <button id="start-button" class="px-10 py-4 bg-accent-blue text-primary-dark text-lg font-extrabold rounded-full hover:bg-sky-300 transition duration-300 pointer-events:auto">
        ENTER THE GRID
      </button>
    </div>
  </div>

<script>
/* ===== FIREBASE CONFIG ===== */
const firebaseConfig = {
  apiKey: "AIzaSyAZ5Xc4Hl1_bN9KLf8S32OxSH_P6JOZwx0",
  authDomain: "fpsmult-5f414.firebaseapp.com",
  projectId: "fpsmult-5f414",
  storageBucket: "fpsmult-5f414.firebasestorage.app",
  messagingSenderId: "353781130843",
  appId: "1:353781130843:web:3a04c9d1f49b52f153417e"
};

/* ===== INIT FIREBASE ===== */
firebase.initializeApp(firebaseConfig);
const auth = firebase.auth();
const db = firebase.firestore();

/* ===== GLOBAL VARS ===== */
const appId = "default-app-id";
let PLAYER_ID = null;
let gameCollectionRef = null;
let playerDocRef = null;

let scene, camera, renderer, clock, world;
let playerObject, headMesh, playerBody;
const otherPlayers = {};
let isLocked = false;
let onMouseMove; // To hold the mouse move handler

const PLAYER_HEIGHT = 12;
const PLAYER_RADIUS = 2;
const PLAYER_HALF_HEIGHT = PLAYER_HEIGHT / 2;
const MOVE_SPEED = 15; // Adjusted for physics velocity
const JUMP_FORCE = 350;
const PLAYER_SYNC_RATE = 100;
let lastSyncTime = 0;
let isDead = false;
let respawnTimer = 0;
const RESPAWN_POSITION = new CANNON.Vec3(0, 5, 80);

const ARENA_SIZE = 400;

const PLATFORMS_DATA = [
    { pos: new THREE.Vector3(0, -2.5, 0), size: new THREE.Vector3(ARENA_SIZE, 5, ARENA_SIZE), color: 0x101a2c },
    { pos: new THREE.Vector3(0, 2.5, 0), size: new THREE.Vector3(60, 5, 60), color: 0x1e293b },
    { pos: new THREE.Vector3(0, 32.5, -100), size: new THREE.Vector3(50, 5, 50), color: 0x1e293b },
    { pos: new THREE.Vector3(-45, 17.5, -50), size: new THREE.Vector3(20, 5, 120), color: 0x2dd4bf, rotation: new THREE.Euler(0, 0, -0.25) },
    { pos: new THREE.Vector3(45, 17.5, -50), size: new THREE.Vector3(20, 5, 120), color: 0x2dd4bf, rotation: new THREE.Euler(0, 0, 0.25) },
    { pos: new THREE.Vector3(-60, 20, -60), size: new THREE.Vector3(10, 40, 10), color: 0x00ffaa, opacity: 0.7 },
    { pos: new THREE.Vector3(60, 20, -60), size: new THREE.Vector3(10, 40, 10), color: 0x00ffaa, opacity: 0.7 },
    { pos: new THREE.Vector3(60, 20, 60), size: new THREE.Vector3(10, 40, 10), color: 0x00ffaa, opacity: 0.7 },
    { pos: new THREE.Vector3(-60, 20, 60), size: new THREE.Vector3(10, 40, 10), color: 0x00ffaa, opacity: 0.7 },
];

const objectsToUpdate = [];
const keyState = { w:false, a:false, s:false, d:false, space:false };

/* DOM */
const gameContainer = document.getElementById('game-container');
const fpsDisplay = document.getElementById('fps-display');
const playerCountDisplay = document.getElementById('player-count-display');
const userIdDisplay = document.getElementById('user-id-display');
const statusMessage = document.getElementById('status-message');
const startButton = document.getElementById('start-button');
const instructionsPanel = document.getElementById('instructions');
const nameInput = document.getElementById('name-input');

/* ===== PLAYER EXIT LOGIC ===== */
async function exitGame() {
    if (playerDocRef) {
        await playerDocRef.delete().catch(err => console.error("Error deleting player doc:", err));
    }
    document.exitPointerLock();
    location.reload();
}

window.addEventListener('beforeunload', async () => {
  if (playerDocRef) { await playerDocRef.delete(); }
});

/* ===== FIRESTORE HELPERS ===== */
function getGameCollectionRefs() {
  const artifacts = db.collection('artifacts').doc(appId);
  const publicDoc = artifacts.collection('public').doc('data');
  const playersColl = publicDoc.collection('fps_players');
  return { playersColl };
}

/* ===== SYNC STATE ===== */
async function syncLocalPlayerState() {
  if (!PLAYER_ID || !playerBody || !playerDocRef || isDead) return;
  const now = Date.now();
  if (now - lastSyncTime < PLAYER_SYNC_RATE) return;
  lastSyncTime = now;

  const playerState = {
    id: PLAYER_ID,
    playerName: nameInput.value || 'Anon',
    position: { x: playerBody.position.x, y: playerBody.position.y, z: playerBody.position.z },
    rotation: { x: headMesh.rotation.x, y: playerObject.rotation.y, z: 0 },
    isDead,
    timestamp: firebase.firestore.FieldValue.serverTimestamp()
  };

  try {
    await playerDocRef.set(playerState, { merge:true });
  } catch (err) { console.error("Write error:", err); }
}

/* ===== LISTENERS AND REMOTE PLAYERS ===== */
function setupMultiplayerListener() {
  if (!gameCollectionRef) return;
  gameCollectionRef.onSnapshot(snapshot => {
    snapshot.docChanges().forEach(change => {
      const id = change.doc.id;
      const data = change.doc.data();
      if (id === PLAYER_ID) return;

      if (change.type === "added") {
        addOtherPlayer(id, data);
      } else if (change.type === "modified") {
        updateOtherPlayerData(id, data);
      } else if (change.type === "removed") {
        removeOtherPlayer(id);
      }
    });
    playerCountDisplay.textContent = `Players: ${Object.keys(otherPlayers).length + (PLAYER_ID?1:0)}`;
  }, err => { console.error("Listen error:", err); });
}

function addOtherPlayer(id, data) {
    const { playerGroup, head } = createPlayerModel(Math.random() * 0xffffff);
    playerGroup.position.set(data.position.x, data.position.y, data.position.z);
    
    const playerName = data.playerName || 'Anon';
    const spriteMap = new THREE.TextureLoader().load(`https://placehold.co/128x32/1e293b/00ffaa?text=${encodeURIComponent(playerName)}`);
    const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: spriteMap }));
    sprite.scale.set(12, 3, 1);
    sprite.position.y = PLAYER_HEIGHT + 6;
    playerGroup.add(sprite);

    scene.add(playerGroup);

    otherPlayers[id] = {
        mesh: playerGroup,
        head: head,
        // Remote players don't need physics bodies, we just move their mesh
        targetPosition: new THREE.Vector3().copy(playerGroup.position),
        targetBodyQuaternion: new THREE.Quaternion(),
        targetHeadPitch: 0,
    };
}

function updateOtherPlayerData(id, data) {
    const entry = otherPlayers[id];
    if (!entry || !data.position || !data.rotation) return;
    
    entry.targetPosition.set(data.position.x, data.position.y, data.position.z);
    
    const bodyEuler = new THREE.Euler(0, data.rotation.y, 0, 'YXZ');
    entry.targetBodyQuaternion.setFromEuler(bodyEuler);
    
    entry.targetHeadPitch = data.rotation.x;
    entry.mesh.visible = !data.isDead;
}

function removeOtherPlayer(id) {
  const entry = otherPlayers[id];
  if (!entry) return;
  scene.remove(entry.mesh);
  delete otherPlayers[id];
}

function updateRemotePlayers(delta) {
    const interpolationFactor = delta * 15;
    for (const id in otherPlayers) {
        const player = otherPlayers[id];
        player.mesh.position.lerp(player.targetPosition, interpolationFactor);
        player.mesh.quaternion.slerp(player.targetBodyQuaternion, interpolationFactor);
        player.head.rotation.x = THREE.MathUtils.lerp(player.head.rotation.x, player.targetHeadPitch, interpolationFactor);
    }
}

/* ===== SCENE AND PHYSICS SETUP ===== */
function init() {
  // THREE.js Scene
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0f172a);
  scene.fog = new THREE.Fog(0x0f172a, 50, 450);

  camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.5, 1000);
  
  // Cannon-es World
  world = new CANNON.World({
    gravity: new CANNON.Vec3(0, -30, 0), // Stronger gravity
  });

  // Player Visuals
  const { playerGroup, head } = createPlayerModel(0x2dd4bf);
  playerObject = playerGroup;
  headMesh = head;
  playerObject.traverse(child => { if (child.isMesh) child.visible = false; });
  headMesh.add(camera);
  scene.add(playerObject);

  // Player Physics Body (Capsule-like)
  playerBody = new CANNON.Body({
      mass: 5,
      position: RESPAWN_POSITION,
      shape: new CANNON.Sphere(PLAYER_RADIUS),
  });
  playerBody.fixedRotation = true; // Prevents tipping over
  playerBody.updateMassProperties();
  world.addBody(playerBody);

  // Link Player Visuals and Physics
  objectsToUpdate.push({ mesh: playerObject, body: playerBody });

  renderer = new THREE.WebGLRenderer({ antialias:true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  gameContainer.appendChild(renderer.domElement);

  // Lights and Helpers
  const ambient = new THREE.AmbientLight(0xaaaaaa, 0.8); scene.add(ambient);
  const dir = new THREE.DirectionalLight(0xffffff, 4); dir.position.set(200,300,200); scene.add(dir);
  const gridHelper = new THREE.GridHelper(ARENA_SIZE, ARENA_SIZE/10, 0x38bdf8, 0x00ffaa);
  gridHelper.material.opacity = 0.5; gridHelper.material.transparent = true; gridHelper.position.y = 0; scene.add(gridHelper);

  // Create platforms with physics
  PLATFORMS_DATA.forEach(d => {
    const mat = new THREE.MeshLambertMaterial({ color:d.color, transparent: d.opacity<1, opacity:d.opacity });
    const mesh = new THREE.Mesh(new THREE.BoxGeometry(d.size.x, d.size.y, d.size.z), mat);
    mesh.position.copy(d.pos);
    if(d.rotation) mesh.rotation.copy(d.rotation);
    scene.add(mesh);

    // Create corresponding physics body
    const shape = new CANNON.Box(new CANNON.Vec3(d.size.x / 2, d.size.y / 2, d.size.z / 2));
    const body = new CANNON.Body({ mass: 0, shape }); // mass 0 makes it static
    body.position.copy(mesh.position);
    body.quaternion.copy(mesh.quaternion);
    world.addBody(body);
  });

  window.addEventListener('resize', onWindowResize, false);
}

function onWindowResize() {
  if (!camera || !renderer) return;
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

/* ===== INPUT / CONTROLS ===== */
function setupControls() {
    onMouseMove = (e) => {
        if (!isLocked) return;
        const mx = e.movementX || 0;
        const my = e.movementY || 0;
        const sensitivity = 0.002;
        playerObject.rotation.y -= mx * sensitivity;
        const newPitch = headMesh.rotation.x - my * sensitivity;
        headMesh.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, newPitch));
    };

    const lockChangeAlert = () => {
        if (document.pointerLockElement === gameContainer) {
            isLocked = true;
            document.addEventListener('mousemove', onMouseMove, false);
        } else {
            isLocked = false;
            document.removeEventListener('mousemove', onMouseMove, false);
            exitGame();
        }
    };
    document.addEventListener('pointerlockchange', lockChangeAlert, false);

  document.addEventListener('keydown', (ev) => {
    if (!isLocked || isDead) return;
    keyState[ev.code.replace('Key', '').toLowerCase()] = true;
    if (ev.code === 'Space') keyState.space = true;
  });

  document.addEventListener('keyup', (ev) => {
    if (!isLocked || isDead) return;
    keyState[ev.code.replace('Key', '').toLowerCase()] = false;
    if (ev.code === 'Space') keyState.space = false;
  });
}

/* ===== MOVEMENT AND PHYSICS ===== */
function updateMovement() {
    if (isDead) {
        playerBody.velocity.set(0,0,0);
        return;
    }

    const direction = new THREE.Vector3();
    direction.z = Number(keyState.s) - Number(keyState.w);
    direction.x = Number(keyState.d) - Number(keyState.a);
    direction.normalize();

    const moveVector = new THREE.Vector3();
    if (keyState.w || keyState.s) moveVector.z = direction.z * MOVE_SPEED;
    if (keyState.a || keyState.d) moveVector.x = direction.x * MOVE_SPEED;

    moveVector.applyQuaternion(playerObject.quaternion);

    // Apply velocity to physics body
    playerBody.velocity.x = moveVector.x;
    playerBody.velocity.z = moveVector.z;
    
    // Jumping
    const groundContact = new CANNON.Ray(playerBody.position, new CANNON.Vec3(0, -1, 0));
    const result = new CANNON.RaycastResult();
    world.raycastClosest(groundContact.from, groundContact.to, {}, result);
    const onGround = result.hasHit && result.distance < PLAYER_RADIUS + 0.1;

    if (keyState.space && onGround) {
        playerBody.applyImpulse(new CANNON.Vec3(0, JUMP_FORCE, 0));
        keyState.space = false; // prevent multi-jump
    }
}


function handleDeathAndRespawn() {
  if (!isDead && playerBody.position.y < -50) {
    isDead = true; 
    respawnTimer = 5000;
    statusMessage.textContent = "FATAL ERROR: Fall detected. Respawning in 5.0s...";
  }

  if (isDead) {
    playerObject.visible = false;
    respawnTimer -= clock.getDelta() * 1000;
    if (respawnTimer <= 0) {
      isDead = false;
      playerObject.visible = true;
      playerBody.position.copy(RESPAWN_POSITION);
      playerBody.velocity.set(0, 0, 0);
      statusMessage.textContent = "";
    }
  }
}

/* ===== ANIMATION LOOP ===== */
function animate() {
  requestAnimationFrame(animate);
  const delta = clock.getDelta();
  const fps = 1 / delta;
  fpsDisplay.textContent = `FPS: ${Math.round(fps)}`;
  
  // Update physics world
  world.step(1/60, delta);

  updateMovement();
  handleDeathAndRespawn();
  
  // Sync physics bodies with three.js meshes
  for(const obj of objectsToUpdate){
    obj.mesh.position.copy(obj.body.position);
    obj.mesh.quaternion.copy(obj.body.quaternion);
  }
  
  updateRemotePlayers(delta);

  syncLocalPlayerState();
  renderer.render(scene, camera);
}

/* ===== GAME START / AUTH ===== */
async function setupAuthAndStartGame() {
  if (nameInput.value.trim() === '') {
    statusMessage.textContent = 'Please enter a name.';
    return;
  }
  startButton.disabled = true;
  nameInput.disabled = true;
  statusMessage.textContent = 'Authenticating...';
  
  try {
    const cred = await auth.signInAnonymously();
    PLAYER_ID = cred.user.uid;
    userIdDisplay.textContent = `User ID: ${PLAYER_ID}`;

    const { playersColl } = getGameCollectionRefs();
    gameCollectionRef = playersColl;
    playerDocRef = playersColl.doc(PLAYER_ID);

    await playerDocRef.set({
      id: PLAYER_ID,
      playerName: nameInput.value,
      position: { x: RESPAWN_POSITION.x, y: RESPAWN_POSITION.y, z: RESPAWN_POSITION.z },
      rotation: { x: 0, y: 0, z: 0 },
      isDead: false,
      timestamp: firebase.firestore.FieldValue.serverTimestamp()
    });

    init();
    setupControls();
    setupMultiplayerListener();
    clock = new THREE.Clock();
    animate();
    statusMessage.textContent = '';
    
    // Fix: Force UI and controls active immediately
    isLocked = true;
    instructionsPanel.style.display = 'none';
    document.addEventListener('mousemove', onMouseMove, false);

  } catch (err) {
    console.error("Auth/start error:", err);
    statusMessage.textContent = 'Auth failed. Check console.';
    startButton.disabled = false;
    nameInput.disabled = false;
  }
}

/* ===== ENTRY POINT BINDING ===== */
window.onload = () => {
  startButton.disabled = true;
  statusMessage.textContent = 'Initializing Firebase...';
  
  startButton.addEventListener('click', () => {
      gameContainer.requestPointerLock?.();
      setupAuthAndStartGame();
  });

  const checkReady = () => {
    if (typeof firebase !== 'undefined' && typeof db !== 'undefined' && typeof auth !== 'undefined') {
      startButton.disabled = false;
      statusMessage.textContent = 'Ready to enter the grid.';
    } else {
      setTimeout(checkReady, 100);
    }
  };
  setTimeout(checkReady, 50);
};
</script>
</body>
</html>